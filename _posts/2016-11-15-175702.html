---
layout: post
title: Coqで既存の定理、定義に従って計算する。
tags:
- Coq

---
{% raw %}

<div class="section">
    <h3>定義に従って計算する</h3>
    <p>定義に従って計算するには、simpl, compute, unfoldが使えます。<br />
simpl.はゴールの式をいい感じに簡単にしてくれるのに対し、compute.はとりあえず式展開します。また、unfoldは定義の左辺から右辺に書き換えます。</p>
<pre class="code" data-lang="" data-unlink>Fixpoint fact (n : nat) : nat :=
  match n with
    | O =&gt; 1
    | S n&#39; =&gt; n * fact n&#39;
  end.

Example fact_example1:
  forall n : nat, fact (S n) = S n * fact n.
Proof.
  intros n.
  simpl.
  (* ここでのゴール:
   * fact n + n * fact n = fact n + n * fact n
   *)
  reflexivity.
Qed.

Definition mult n m := n * m.

Goal forall n m : nat, mult n m = n * m.
Proof.
  intros n m.
  (* Goal: mult n m = n * m *)
  unfold mult.
  (* Goal: n * m = n * m *)
  reflexivity.
Qed.</pre>
</div>
<div class="section">
    <h3>定理を用いて書き換える</h3>
    <p>前提や既に定義された定理として等式がある場合、<a class="keyword" href="http://d.hatena.ne.jp/keyword/rewrite">rewrite</a>を使うことで書き換えることができます。</p>
<pre class="code" data-lang="" data-unlink>Goal forall (T : Type) (x : T) (f g : T -&gt; T),
       g (f x) = x -&gt; g (f (g (f x))) = x.
Proof.
  intros T x f g H. (* H : g (f x) = x *)
  (* この時点でのゴール: g (f (g (f x))) = x *)
  rewrite -&gt; H. (* Hを用いて、ゴールの左辺を右辺に書き換える *)
  (* この時点でのゴール: g (f x) = x *)
  rewrite -&gt; H. (* もう一度適用 *)
  (* この時点でのゴール: x = x *)
  reflexivity.
Qed.</pre><p>等式Hを用いて左辺を右辺に置き換える場合は-&gt;, 右辺を左辺に書き換える場合は&lt;-を使います。</p><p>また、simpl in H, <a class="keyword" href="http://d.hatena.ne.jp/keyword/rewrite">rewrite</a> -> ... in Hを使うことで、ゴールではなく前提にある式の項を書き換えることができます。</p>
<pre class="code" data-lang="" data-unlink>Goal forall P : Prop, 1 + 1 = 0 -&gt; P.
Proof.
  intros P H. (* H : 1 + 1 = 0 *)
  simpl in H. (* H : 2 = 0 *)
  discriminate.
Qed.</pre>
</div>

{% endraw %}
