---
layout: post
title: Coqで前提の矛盾から定理を証明する
tags:
- Coq

---
{% raw %}
<p>矛盾を導く方法は何通りかあります。</p>

<div class="section">
    <h3>すでに前提にFalseがある場合。</h3>
    <p>まずは一番基本的な方法から。既に前提にFalseがある場合です。<br />
Falseの定義は、以下のようになっています。</p>
<pre class="code" data-lang="" data-unlink>Inductive False := (* コンストラクタが1つもない *).</pre><p>従って、前提にP : Falseがある場合、destruct P.してしまえばその瞬間にPのすべてのケースについて証明が終了したこととなり、定理が示せます。</p>
<pre class="code" data-lang="" data-unlink>Goal forall Q : Prop, False -&gt; Q.
Proof.
  intros Q F. (* Q : Prop, F : False *)
  destruct F.
Qed</pre><p>これが一番基本的な方法です。<br />
他の方法はすべてこの操作+αを自動でやってくれているだけなので、<b>面倒であればこの方法以外覚えなくても大丈夫です。</b></p><p>また、Falseから任意の命題を導く専用のタクティック、contradictionもあります。使い方は先ほどと同じです。</p>
<pre class="code" data-lang="" data-unlink>Goal forall Q : Prop, False -&gt; Q.
Proof.
  intros Q F. (* F : False *)
  contradiction.
Qed.</pre>
</div>
<div class="section">
    <h3>前提からFalseが導けそうな場合。</h3>
    <p>elimtype False.をすると、ゴールがFalseになります。あとは前提を適当に弄ってFalseを導ければ証明終了です。</p>
<pre class="code" data-lang="" data-unlink>Goal forall P Q : Prop,
       P -&gt; ~ P -&gt; Q.
Proof.
  intros P Q P1 NP. (* P1 : P, NP : ~ P *)
  elimtype False. (* ここでゴールがQでなくFalseになる *)
  apply NP in P1. (* P1 : False *)
  apply P1.
Qed.</pre><p>ちなみに、~ PはP -> Falseの略記なので、apply NP in P1.とするとFalseが導けます。</p><p>elimtype Falseと全く同様のことをするタクティックとして、exfalsoというものがあります。</p>
<pre class="code" data-lang="" data-unlink>Goal forall P Q : Prop, P -&gt; ~ P -&gt; Q.
Proof.
  intros P Q HP NP. (* HP : P, NP : ~ P *)
  exfalso. (* ここでゴールがFalseになる *)
  apply NP in HP.
  assumption.
Qed.</pre><p>また、前提からFalseが導けそうな場合も、先ほどのcontradictionタクティックを使うことができます。</p>
<pre class="code" data-lang="" data-unlink>Goal forall P Q : Prop, P -&gt; ~ P -&gt; Q.
Proof.
  intros P Q HP NP. (* HP : P, NP : ~ P *)
  contradiction.
Qed.</pre><p>また、contradiction H.とすることで、矛盾を導くヒントとして命題Hを与えることもできます。</p>
<pre class="code" data-lang="" data-unlink>Goal forall P Q : Prop, P -&gt; ~ P -&gt; Q.
Proof.
  intros P Q HP NP. (* HP : P, NP : ~ P *)
  contradiction HP.
Qed.</pre>
</div>
<div class="section">
    <h3>前提からPと~ Pが導けそうな場合。</h3>
    <p>absurd P.をすると、ゴールがPと~ Pの2つになります。それらを証明すると、そこから自動的にFalseを導いてくれて証明終了になります。</p>
<pre class="code" data-lang="" data-unlink>Goal forall P Q R : Prop,
       P -&gt; Q -&gt; (Q -&gt; ~ P) -&gt; R.
Proof.
  intros P Q R H0 H1 H2. (* H0 : P, H1 : Q, H2 : Q -&gt; ~ P *)
  absurd P. (* ここでゴールが P と ~ P に変わる *)
  - (* ~ P の証明 *)
    apply H2 in H1.
    apply H1.
  - (* P の証明 *)
    apply H0.
Qed.</pre>
</div>
<div class="section">
    <h3>前提に明らかに成り立たない等式がある場合</h3>
    <p>discriminate.をすると、前提にある明らかに成り立たない不等式を自動で発見して、そこからFalseを導いて定理を証明してくれます。</p>
<pre class="code" data-lang="" data-unlink>Goal 0 = 1 -&gt; 1 + 1 = 334.
Proof.
  intros H. (* H : 0 = 1 *)
  discriminate.
Qed.</pre><p>このProofでは1行目にintrosをしていますが、discriminateは自動でintrosもやってくれるようなので、これは無くてもいいです。</p>

</div>
<div class="section">
    <h3>前提に明らかに左右の等しい不等式がある場合</h3>
    <p>congruence.をすると、前提にある明らかに左右の等しい不等式を利用して定理を証明してくれます。</p>
<pre class="code" data-lang="" data-unlink>Goal forall (x : nat) (P : Prop),
       x &lt;&gt; x -&gt; P.
Proof.
  intros x p H. (* H : x &lt;&gt; x. ちなみにCoqでは不等号は&lt;&gt;です *)
  congruence.
Qed.</pre><p>ちなみにcongruenceも自動でintrosしてくれるので、1行目は必要なかったりします。</p>

</div>

{% endraw %}
