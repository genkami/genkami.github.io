---
layout: post
title: Elm始めてみました。
tags:
- Elm

---
{% raw %}
<p>Elmという言語を一ヶ月ほど触ってみたので、この言語の特徴などを紹介したいと思います。</p>

<div class="section">
    <h3>Elmとは</h3>
    <p><a href="http://elm-lang.org/">http://elm-lang.org/</a></p><p>この言語はざっくりと言うと、「<a class="keyword" href="http://d.hatena.ne.jp/keyword/JavaScript">JavaScript</a>に<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB">コンパイル</a>される、純粋関数型で<a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a>っぽい文法の言語」です。</p>

</div>
<div class="section">
    <h3>純粋関数型</h3>
    <p>Elmは<a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a>と同様に純粋関数型(と通常はみなすことができる)言語です。基本的に、Elmの中ではどのような副作用も起こすことはできませんが、後述するThe Elm Architectureにより外界との通信などを行うことができます。</p><p>Elmは<a class="keyword" href="http://d.hatena.ne.jp/keyword/%B4%D8%BF%F4%B7%BF%B8%C0%B8%EC">関数型言語</a>に特徴的な機能のほとんどを持っています。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synComment">-- 代数的データ型</span>
<span class="synType">type</span> Hoge <span class="synStatement">=</span> Hoge <span class="synStatement">|</span> Fuga

<span class="synComment">-- レコード型</span>
<span class="synType">type</span> alias Person <span class="synStatement">=</span>
    { name <span class="synStatement">:</span> String
    , age <span class="synStatement">:</span> Int
    , address <span class="synStatement">:</span> String
    }

<span class="synComment">-- パターンマッチ</span>
toStr <span class="synStatement">:</span> Hoge <span class="synStatement">-&gt;</span> String
toStr hoge <span class="synStatement">=</span>
    <span class="synStatement">case</span> hoge <span class="synStatement">of</span>
        Hoge <span class="synStatement">-&gt;</span> <span class="synConstant">&quot;hoge&quot;</span>
        Fuga <span class="synStatement">-&gt;</span> <span class="synConstant">&quot;fuga&quot;</span>
</pre><p>また、MaybeやResult(Eitherに相当)など、関数型的プログラミングをするために必要な型も一通りそろっています。<br />
文法はかなり<a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a>に近いですが、正格評価だったり型クラスがなかったりするので中身はあまり<a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a>っぽくありません。むしろ<a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a>に近いかもしれません。</p>

</div>
<div class="section">
    <h3>The Elm ArchitectureによるIOの実現</h3>
    <p>Elmは純粋<a class="keyword" href="http://d.hatena.ne.jp/keyword/%B4%D8%BF%F4%B7%BF%B8%C0%B8%EC">関数型言語</a>ですが、<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>も一意型もありません。それではどのようにして副作用を実現しているのかというと、<a class="keyword" href="http://d.hatena.ne.jp/keyword/FRP">FRP</a>の概念を元にして作られたThe Elm Architectureという<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF">フレームワーク</a>を利用します。基本的に、全てのプログラムはModel, Msg, view, update, subscriptionsの5つからなります。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synType">type</span> Model <span class="synStatement">=</span> (アプリケーションの状態管理に使用するデータ型)
<span class="synType">type</span> Msg <span class="synStatement">=</span> (外界との通信に必要な型)
init <span class="synStatement">:</span> (Model, Cmd Msg) <span class="synComment">-- 初期状態</span>
view <span class="synStatement">:</span> Model <span class="synStatement">-&gt;</span> Html msg <span class="synComment">-- 表示</span>
update <span class="synStatement">:</span> Msg <span class="synStatement">-&gt;</span> Model <span class="synStatement">-&gt;</span> (Model, Cmd Msg)
subscriptions <span class="synStatement">:</span> Model <span class="synStatement">-&gt;</span> Sub Msg
</pre><p>Model, viewについての説明は不要だと思いますが。Elmには見慣れないupdate, subscriptionsという2つの関数があります。<br />
The Elm Architectureの考え方の根本は<a class="keyword" href="http://d.hatena.ne.jp/keyword/FRP">FRP</a>なので、外界で発生するイベントは時系列に並んだリストのようなものと考えることができます。updateはこれらを畳み込んでModelを変化させていく関数です。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>update (マウスクリックを表すイベント) model <span class="synStatement">=</span> (イベント処理の終わったmodel, cmd)
</pre><p>updateは更新後のmodelの値の他にCmd Msgという謎の値も返していますが、これは外界への命令を表します。外界への命令というのは、例えば「hogehoge.comにGETリクエスト送っといて」とか「ランダムに整数生成しといて」といったIOの絡むものを表します。これらを表すCmd Msg型の値を返すと、その結果がMsg型となって後のupdateの引数に渡されていきます。</p><p>もうひとつの関数subscriptionsは、マウスのクリックや時間の経過等無数にあるイベントのうち、どのイベントをupdateの引数として通知して欲しいかを表します。</p><p>これらの関数を利用して、IOの必要な処理をCmdとして外界に送信し、返ってきた値をupdateの引数として受け取り、さらに処理を続けていく…といったループが、Elmのプログラムの基本的な書き方となります。</p>

</div>
<div class="section">
    <h3>Taskによる非同期処理</h3>
    <p>Elmではhttpリクエストの送信などの非同期で行いたい処理をTaskという概念を用いて行います。<br />
TaskはTask.attemptという関数によりCmdに変換され、それをupdateで送信することによって実行後にMsgとなって返ってきます。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synType">type</span> Msg <span class="synStatement">=</span> Users (List String) <span class="synStatement">|</span> <span class="synStatement">...</span>

<span class="synComment">-- api.example.com/users にリクエストを送るタスク</span>
getUsers <span class="synStatement">:</span> Task Http.Error (List String)
getUsers <span class="synStatement">=</span> Http.get (list string) <span class="synConstant">&quot;http://api.example.com/users&quot;</span>
</pre><p>こうしてできたタスクは、Task.performという関数によりCmdに変換され、updateを使って送信されます。<br />
そして、返ってきた値がMsgとなってupdateに渡されるという流れになっています。</p>

</div>
<div class="section">
    <h3>portによるJSとの連携</h3>
    <p>JSで書かれたコードとのやり取りは、portという機能を介して行われます。<br />
ポートには入力ポートと出力ポートの2種類があり、それぞれ次のように定義します。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synComment">-- 出力ポート</span>
port outPort <span class="synStatement">:</span> String <span class="synStatement">-&gt;</span> Cmd msg
<span class="synComment">-- 入力ポート。引数を使ってポートからの値をmsgに変換する。</span>
port inPort <span class="synStatement">:</span> (String <span class="synStatement">-&gt;</span> msg) <span class="synStatement">-&gt;</span> Sub msg
</pre><p>Stringの部分はJSとのやり取りに指定したい型です。別にStringじゃなくても構いません。<br />
このようにして定義したportを、先ほど説明したupdateにより外界に渡し、subscriptionsにより受け取ることができます。<br />
Elmとやり取りするためのJSのコードは以下のようになります。</p>
<pre class="code lang-javascript" data-lang="javascript" data-unlink><span class="synIdentifier">var</span> app = Elm.Main.fullscreen();
<span class="synComment">// 出力ポートからの値の受け取り</span>
app.ports.outPort.subscribe((str) =&gt; <span class="synIdentifier">{</span>
    (適当な処理);
    app.ports.inPort.send(<span class="synConstant">'何らかのメッセージ'</span>)
<span class="synIdentifier">}</span>);
</pre><p>これだけです。簡単ですね。<br />
この機能により、容易に<a class="keyword" href="http://d.hatena.ne.jp/keyword/JavaScript">JavaScript</a>で書かれたコードとの連携を取ることができます。そのため、JSで書かれたアプリケーションの一部にElmを使ったり、その逆を行うことも可能です。</p><br />
<p>以上がElmの主な特徴になります。<br />
<a class="keyword" href="http://d.hatena.ne.jp/keyword/FRP">FRP</a>を前提とした言語というのは他では聞いたことがありませんし、一度やってみるのも面白いのではないでしょうか？</p><p>次回はElmに関する愚痴とかを書きます。</p>

</div>

{% endraw %}
