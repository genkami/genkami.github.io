---
layout: post
title: Emacs Lispにおける関数の扱い
tags:
- Emacs

---
{% raw %}
<p>他の人の<a class="keyword" href="http://d.hatena.ne.jp/keyword/Emacs%20Lisp">Emacs Lisp</a>の設定を眺めていて気づいたのですが、(add-hook <a class="keyword" href="http://d.hatena.ne.jp/keyword/hoge">hoge</a>-hook XXXX)のXXXX部分にlambdaを入れる場合、</p>
<pre class="code lang-lisp" data-lang="lisp" data-unlink><span class="synSpecial">(</span><span class="synStatement">lambda</span> <span class="synSpecial">()</span> ...<span class="synSpecial">)</span>
</pre><p>と普通に書く人と、</p>
<pre class="code lang-lisp" data-lang="lisp" data-unlink><span class="synSpecial">'(</span><span class="synStatement">lambda</span> <span class="synSpecial">()</span> ...<span class="synSpecial">)</span>
</pre><p>みたいにクオートして書く人と、</p>
<pre class="code lang-lisp" data-lang="lisp" data-unlink>#<span class="synSpecial">'(</span><span class="synStatement">lambda</span> <span class="synSpecial">()</span> ...<span class="synSpecial">)</span>
</pre><p>みたいな謎クオートする人がいますよね。</p><p>このへんのうち、実際どのやり方が正しくてどれが間違っているのかよく知らなかったので、<a class="keyword" href="http://d.hatena.ne.jp/keyword/Emacs%20Lisp">Emacs Lisp</a>における関数について調べてみました。</p><br />
<br />
<p><a class="keyword" href="http://d.hatena.ne.jp/keyword/Emacs%20Lisp">Emacs Lisp</a>はいわゆる<a class="keyword" href="http://d.hatena.ne.jp/keyword/Lisp">Lisp</a>-2なので、変数と関数は別々の<a class="keyword" href="http://d.hatena.ne.jp/keyword/%CC%BE%C1%B0%B6%F5%B4%D6">名前空間</a>に存在します。</p>
<pre class="code lang-lisp" data-lang="lisp" data-unlink><span class="synSpecial">(</span>global-set-key <span class="synSpecial">(</span>kbd <span class="synConstant">&quot;C-p&quot;</span><span class="synSpecial">)</span> previous-line<span class="synSpecial">)</span> <span class="synComment">; NG!!</span>
<span class="synComment">;; =&gt; Symbol's value as variable is void: previous-line</span>

<span class="synSpecial">(</span>global-set-key <span class="synSpecial">(</span>kbd <span class="synConstant">&quot;C-p&quot;</span><span class="synSpecial">)</span> <span class="synSpecial">'</span><span class="synIdentifier">previous-line</span><span class="synSpecial">)</span> <span class="synComment">; OK!!</span>
</pre><p>関数名から関数自身を取得するにはsymbol-functionを使用し、関数名を指定して呼び出すにはfuncallを使用します。</p>
<pre class="code lang-lisp" data-lang="lisp" data-unlink><span class="synSpecial">(</span><span class="synStatement">defun</span> print-hoge <span class="synSpecial">(</span>fuga<span class="synSpecial">)</span>
  <span class="synSpecial">(</span>message <span class="synConstant">&quot;hoge %s&quot;</span> fuga<span class="synSpecial">))</span>

<span class="synSpecial">(</span><span class="synStatement">symbol-function</span> <span class="synSpecial">'</span><span class="synIdentifier">print-hoge</span><span class="synSpecial">)</span>
<span class="synComment">;; =&gt; (lambda (fuga) (message &quot;hoge %s&quot; fuga))</span>

<span class="synSpecial">(</span><span class="synStatement">funcall</span> <span class="synSpecial">'</span><span class="synIdentifier">print-hoge</span> <span class="synConstant">&quot;fuga&quot;</span><span class="synSpecial">)</span>
<span class="synComment">;; =&gt; hoge fuga</span>
</pre><p>しかし、symbol-functionで手に入れた関数本体をそのまま呼び出せるかといえば、そういうわけでもないみたいです。</p>
<pre class="code lang-lisp" data-lang="lisp" data-unlink><span class="synSpecial">((</span><span class="synStatement">symbol-function</span> <span class="synSpecial">'</span><span class="synIdentifier">print-hoge</span><span class="synSpecial">)</span> <span class="synConstant">&quot;fuga&quot;</span><span class="synSpecial">)</span>
<span class="synComment">;; =&gt; Invalid function: (symbol-function (quote print-hoge))</span>
</pre><p>エラーメッセージから察するに、S式の関数に相当する部分を評価せずに扱っているようです。<br />
この関数部分がシンボルで、それが実際に存在する関数の名前であるか、もしくはリストで、それが正しい<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E9%A5%E0%A5%C0%BC%B0">ラムダ式</a>を表していれば関数として実行しているっぽいです。</p>
<pre class="code lang-lisp" data-lang="lisp" data-unlink><span class="synSpecial">((</span><span class="synStatement">lambda</span> <span class="synSpecial">(</span>x<span class="synSpecial">)</span> x<span class="synSpecial">)</span> <span class="synConstant">1</span><span class="synSpecial">)</span>
<span class="synComment">;; =&gt; 1</span>
</pre><p>で、このlambdaが曲者。</p>
<pre class="code lang-lisp" data-lang="lisp" data-unlink><span class="synSpecial">(</span><span class="synStatement">lambda</span> <span class="synSpecial">(</span>x<span class="synSpecial">)</span> x<span class="synSpecial">)</span>
<span class="synComment">;; =&gt; (lambda (x) x)</span>

<span class="synSpecial">(</span><span class="synStatement">lambda</span> hoge<span class="synSpecial">)</span>
<span class="synComment">;; =&gt; (lambda hoge)</span>

<span class="synSpecial">(</span><span class="synStatement">lambda</span><span class="synSpecial">)</span>
<span class="synComment">;; =&gt; (lambda)</span>
</pre><p>lambda自体はマクロになっていて、「引数全体をクオートしたリストの頭にlambdaをくっつけて返す」ものになっています。要するに(lambda ...)という形のS式をクオートしてもしなくても同じような式になるようになっています。</p>
<pre class="code lang-lisp" data-lang="lisp" data-unlink><span class="synComment">;; 要するにこんな感じ</span>
<span class="synSpecial">(</span><span class="synStatement">defmacro</span> fun <span class="synSpecial">(</span><span class="synType">&amp;rest</span> body<span class="synSpecial">)</span>
  <span class="synPreProc">`(</span><span class="synStatement">quote</span> <span class="synSpecial">(</span>fun ,@body<span class="synSpecial">)</span><span class="synPreProc">)</span><span class="synSpecial">)</span>

<span class="synSpecial">(</span>fun <span class="synSpecial">(</span>x<span class="synSpecial">)</span> x<span class="synSpecial">)</span>
<span class="synComment">;; =&gt; (fun (x) x)</span>
</pre><p>これのfunを全部lambdaに変えたようなことをやっています。</p><p>そして、もう一つ重要なのは、<a class="keyword" href="http://d.hatena.ne.jp/keyword/Emacs%20Lisp">Emacs Lisp</a>は「頭が'lambdaであるようなリスト」を関数とみなして実行してしまうことです。</p>
<pre class="code lang-lisp" data-lang="lisp" data-unlink><span class="synSpecial">(</span><span class="synStatement">funcall</span> <span class="synSpecial">'(</span><span class="synStatement">lambda</span> <span class="synSpecial">(</span>x<span class="synSpecial">)</span> x<span class="synSpecial">)</span> <span class="synConstant">1</span><span class="synSpecial">)</span>
<span class="synComment">;; =&gt; 1</span>
</pre><p>たぶん<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4">バイ</a>ト<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB">コンパイル</a>とかされたら一人前の関数になってくれるんじゃないかと思いますが[要出典]、基本的に関数はただのリストっぽいです。ただのリストなので<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AF%A5%ED%A1%BC%A5%B8%A5%E3">クロージャ</a>とかいう概念もありません<a href="#f-38e40554" name="fn-38e40554" title="余談ですが、Emacs24以降はlexical bindingをサポートしているようなので、クロージャもどうにかすれば作れるらしいです。">*1</a>。</p>
<pre class="code lang-lisp" data-lang="lisp" data-unlink><span class="synSpecial">(</span><span class="synStatement">defun</span> make-counter <span class="synSpecial">()</span>
  <span class="synSpecial">(</span><span class="synStatement">let</span> <span class="synSpecial">((</span>n <span class="synConstant">0</span><span class="synSpecial">))</span>
    <span class="synSpecial">(</span><span class="synStatement">lambda</span> <span class="synSpecial">()</span>
      <span class="synSpecial">(</span><span class="synStatement">setq</span> n <span class="synSpecial">(</span><span class="synStatement">1+</span> n<span class="synSpecial">))</span>
      n<span class="synSpecial">)))</span>
<span class="synSpecial">(</span><span class="synStatement">defvar</span> counter <span class="synSpecial">(</span>make-counter<span class="synSpecial">))</span>
<span class="synSpecial">(</span><span class="synStatement">listp</span> counter<span class="synSpecial">)</span> <span class="synComment">; =&gt; t</span>
<span class="synSpecial">(</span><span class="synStatement">funcall</span> counter<span class="synSpecial">)</span>
<span class="synComment">;; =&gt; Symbol's value as variable is void: n</span>
</pre><p>で、本題。<br />
lambdaの頭に付けるクオートのうちどれが適切なのかという話ですが、これは#'でクオートするのが正しいようです。</p><p><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Anonymous-Functions.html#Anonymous-Functions">GNU Emacs Lisp Reference Manual: Anonymous Functions</a></p><p>上のドキュメントによると、#'はほぼ'と同様のクオートですが、処理系に「これは関数だよ」と教える機能があるそうです。処理系はそれを元に、#'でクオートされている<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E9%A5%E0%A5%C0%BC%B0">ラムダ式</a>が「実際に関数」であるのか「たまたま頭がlambdaだっただけのリスト」なのかを判断し、前者であればいい感じに<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4">バイ</a>ト<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB">コンパイル</a>してくれたりするそうです。</p>
<div class="footnote">
<p class="footnote"><a href="#fn-38e40554" name="f-38e40554" class="footnote-number">*1</a><span class="footnote-delimiter">:</span><span class="footnote-text">余談ですが、Emacs24以降はlexical bindingをサポートしているようなので、<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AF%A5%ED%A1%BC%A5%B8%A5%E3">クロージャ</a>もどうにかすれば作れるらしいです。</span></p>
</div>

{% endraw %}
