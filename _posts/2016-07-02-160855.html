---
layout: post
title: Haskellで辞書リテラルや集合リテラルを扱う
tags:
- Haskell

---
{% raw %}
<p>OverloadedLists拡張を有効化すると、通常のリスト<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%EA%A5%C6%A5%E9%A5%EB">リテラル</a>の型が[a]からforall t. IsList t => tになります。</p><p>IsList型クラスは<a class="keyword" href="http://d.hatena.ne.jp/keyword/GHC">GHC</a>.Extsで定義されており、以下のような定義になっております。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synType">class</span> IsList l <span class="synType">where</span>
  <span class="synType">type</span> family Item l <span class="synStatement">::</span> <span class="synStatement">*</span>
  fromList <span class="synStatement">::</span> [Item l] <span class="synStatement">-&gt;</span> l
  fromListN <span class="synStatement">::</span> Int <span class="synStatement">-&gt;</span> [Item l] <span class="synStatement">-&gt;</span> l
  toList <span class="synStatement">::</span> l <span class="synStatement">-&gt;</span> [Item l]
</pre><p>定義を読んでいただければわかるかと思いますが、Item lが要素の型であり、Item lのリストとの相互変換が可能なものをIsListの<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9">インスタンス</a>として定義できます。</p><br />
<p>実際に使ってみましょう。とりあえず試しに、Data.Map.Map, Data.Set.Set, Data.Array.ArrayをIsListの<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9">インスタンス</a>にしてみました。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synSpecial">{-# LANGUAGE</span>
<span class="synSpecial">    OverloadedLists</span>
<span class="synSpecial">  , FlexibleInstances</span>
<span class="synSpecial">  , TypeFamilies #-}</span>

<span class="synPreProc">import</span> GHC.Exts (IsList(..))

<span class="synPreProc">import</span> <span class="synPreProc">qualified</span> Data.Array <span class="synPreProc">as</span> A
<span class="synPreProc">import</span> <span class="synPreProc">qualified</span> Data.Map <span class="synPreProc">as</span> M
<span class="synPreProc">import</span> <span class="synPreProc">qualified</span> Data.Set <span class="synPreProc">as</span> S

<span class="synType">instance</span> Ord k <span class="synStatement">=&gt;</span> IsList (M.Map k v) <span class="synType">where</span>
  <span class="synType">type</span> Item (M.Map k v) <span class="synStatement">=</span> (k, v)
  fromList <span class="synStatement">=</span> M.fromList
  toList <span class="synStatement">=</span> M.toList

<span class="synType">instance</span> Ord a <span class="synStatement">=&gt;</span> IsList (S.Set a) <span class="synType">where</span>
  <span class="synType">type</span> Item (S.Set a) <span class="synStatement">=</span> a
  fromList <span class="synStatement">=</span> S.fromList
  toList <span class="synStatement">=</span> S.toList

<span class="synType">instance</span> IsList (A.Array Int a) <span class="synType">where</span>
  <span class="synType">type</span> Item (A.Array Int a) <span class="synStatement">=</span> a
  fromList xs <span class="synStatement">=</span> A.listArray (<span class="synConstant">0</span>, m) xs
    <span class="synType">where</span> m <span class="synStatement">=</span> length xs <span class="synStatement">-</span> <span class="synConstant">1</span>
  toList <span class="synStatement">=</span> A.elems
</pre><p>実際に使用してみると以下のようになります。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synStatement">&gt;&gt;&gt;</span> <span class="synStatement">:</span>l OverloadedList.hs <span class="synComment">-- 先ほどのソースコード</span>
[<span class="synConstant">1</span> <span class="synStatement">of</span> <span class="synConstant">1</span>] Compiling Main             ( OverloadedList.hs, interpreted )
Ok, modules loaded<span class="synStatement">:</span> Main<span class="synStatement">.</span>
<span class="synStatement">&gt;&gt;&gt;</span> <span class="synStatement">:</span>set <span class="synStatement">-</span>XOverloadedLists
<span class="synStatement">&gt;&gt;&gt;</span> <span class="synStatement">:</span>t [<span class="synConstant">1</span>, <span class="synConstant">2</span>, <span class="synConstant">3</span>]
[<span class="synConstant">1</span>, <span class="synConstant">2</span>, <span class="synConstant">3</span>] <span class="synStatement">::</span> (Num (Item l), IsList l) <span class="synStatement">=&gt;</span> l
<span class="synStatement">&gt;&gt;&gt;</span> S.member <span class="synConstant">3</span> [<span class="synConstant">1</span>, <span class="synConstant">2</span>, <span class="synConstant">3</span>, <span class="synConstant">4</span>, <span class="synConstant">5</span>] <span class="synComment">-- Setとして使用してみる</span>
True
<span class="synStatement">&gt;&gt;&gt;</span> M.lookup <span class="synConstant">&quot;Taro&quot;</span> [(<span class="synConstant">&quot;Taro&quot;</span>, <span class="synConstant">&quot;Tokyo&quot;</span>), (<span class="synConstant">&quot;Jiro&quot;</span>, <span class="synConstant">&quot;Osaka&quot;</span>), (<span class="synConstant">&quot;Saburo&quot;</span>, <span class="synConstant">&quot;Sapporo&quot;</span>)] <span class="synComment">-- Mapとして使用してみる</span>
Just <span class="synConstant">&quot;Tokyo&quot;</span>
<span class="synStatement">&gt;&gt;&gt;</span> ([<span class="synConstant">&quot;hoge&quot;</span>, <span class="synConstant">&quot;fuga&quot;</span>, <span class="synConstant">&quot;foo&quot;</span>, <span class="synConstant">&quot;bar&quot;</span>] <span class="synStatement">::</span> A.Array Int String) <span class="synStatement">A.!</span> <span class="synConstant">3</span> <span class="synComment">-- Arrayとして使用してみる</span>
<span class="synConstant">&quot;bar&quot;</span>
</pre><p>Arrayの場合、添字の型が判定できないので型注釈が必要となりますが、大きなプログラムではあまり問題にならないでしょう。</p>


{% endraw %}
