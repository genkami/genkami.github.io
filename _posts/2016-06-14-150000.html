---
layout: post
title: Data.Dataのgfoldlの型を読み解く
tags:
- Haskell

---
{% raw %}
<p>Data.Data.Data型クラスを使うと、Typeableと同様に非常に一般的な関数を書くことができるようになります。</p><p>前回のTypeableは値の型情報を取得するだけでしたが、Dataのメソッドを用いると代数的データ型の任意のフィールドにアクセスするといったようなことができるようになります。</p><p>また、DataもDeriveDataTypeable拡張を利用することにより、任意の型に対してderiveすることができるようになります。</p><p>まずはData型クラスの定義を見てみましょう。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synStatement">&gt;&gt;&gt;</span> <span class="synStatement">:</span>i Data
<span class="synType">class</span> Typeable a <span class="synStatement">=&gt;</span> Data a <span class="synType">where</span>
  gfoldl <span class="synStatement">::</span>
    (forall d b<span class="synStatement">.</span> Data d <span class="synStatement">=&gt;</span> c (d <span class="synStatement">-&gt;</span> b) <span class="synStatement">-&gt;</span> d <span class="synStatement">-&gt;</span> c b)
    <span class="synStatement">-&gt;</span> (forall g<span class="synStatement">.</span> g <span class="synStatement">-&gt;</span> c g) <span class="synStatement">-&gt;</span> a <span class="synStatement">-&gt;</span> c a
  gunfold <span class="synStatement">::</span>
    (forall b r<span class="synStatement">.</span> Data b <span class="synStatement">=&gt;</span> c (b <span class="synStatement">-&gt;</span> r) <span class="synStatement">-&gt;</span> c r)
    <span class="synStatement">-&gt;</span> (forall r<span class="synStatement">.</span> r <span class="synStatement">-&gt;</span> c r) <span class="synStatement">-&gt;</span> Constr <span class="synStatement">-&gt;</span> c a
  toConstr <span class="synStatement">::</span> a <span class="synStatement">-&gt;</span> Constr
  dataTypeOf <span class="synStatement">::</span> a <span class="synStatement">-&gt;</span> DataType
  dataCast1 <span class="synStatement">::</span>
    Typeable t <span class="synStatement">=&gt;</span> (forall d<span class="synStatement">.</span> Data d <span class="synStatement">=&gt;</span> c (t d)) <span class="synStatement">-&gt;</span> Maybe (c a)
  dataCast2 <span class="synStatement">::</span>
    Typeable t <span class="synStatement">=&gt;</span>
    (forall d e<span class="synStatement">.</span> (Data d, Data e) <span class="synStatement">=&gt;</span> c (t d e)) <span class="synStatement">-&gt;</span> Maybe (c a)
  gmapT <span class="synStatement">::</span> (forall b<span class="synStatement">.</span> Data b <span class="synStatement">=&gt;</span> b <span class="synStatement">-&gt;</span> b) <span class="synStatement">-&gt;</span> a <span class="synStatement">-&gt;</span> a
  gmapQl <span class="synStatement">::</span>
    (r <span class="synStatement">-&gt;</span> r' <span class="synStatement">-&gt;</span> r) <span class="synStatement">-&gt;</span> r <span class="synStatement">-&gt;</span> (forall d<span class="synStatement">.</span> Data d <span class="synStatement">=&gt;</span> d <span class="synStatement">-&gt;</span> r') <span class="synStatement">-&gt;</span> a <span class="synStatement">-&gt;</span> r
  gmapQr <span class="synStatement">::</span>
    (r' <span class="synStatement">-&gt;</span> r <span class="synStatement">-&gt;</span> r) <span class="synStatement">-&gt;</span> r <span class="synStatement">-&gt;</span> (forall d<span class="synStatement">.</span> Data d <span class="synStatement">=&gt;</span> d <span class="synStatement">-&gt;</span> r') <span class="synStatement">-&gt;</span> a <span class="synStatement">-&gt;</span> r
  gmapQ <span class="synStatement">::</span> (forall d<span class="synStatement">.</span> Data d <span class="synStatement">=&gt;</span> d <span class="synStatement">-&gt;</span> u) <span class="synStatement">-&gt;</span> a <span class="synStatement">-&gt;</span> [u]
  gmapQi <span class="synStatement">::</span> Int <span class="synStatement">-&gt;</span> (forall d<span class="synStatement">.</span> Data d <span class="synStatement">=&gt;</span> d <span class="synStatement">-&gt;</span> u) <span class="synStatement">-&gt;</span> a <span class="synStatement">-&gt;</span> u
  gmapM <span class="synStatement">::</span> Monad m <span class="synStatement">=&gt;</span> (forall d<span class="synStatement">.</span> Data d <span class="synStatement">=&gt;</span> d <span class="synStatement">-&gt;</span> m d) <span class="synStatement">-&gt;</span> a <span class="synStatement">-&gt;</span> m a
  gmapMp <span class="synStatement">::</span>
    Control.Monad<span class="synStatement">.</span>MonadPlus m <span class="synStatement">=&gt;</span>
    (forall d<span class="synStatement">.</span> Data d <span class="synStatement">=&gt;</span> d <span class="synStatement">-&gt;</span> m d) <span class="synStatement">-&gt;</span> a <span class="synStatement">-&gt;</span> m a
  gmapMo <span class="synStatement">::</span>
    Control.Monad<span class="synStatement">.</span>MonadPlus m <span class="synStatement">=&gt;</span>
    (forall d<span class="synStatement">.</span> Data d <span class="synStatement">=&gt;</span> d <span class="synStatement">-&gt;</span> m d) <span class="synStatement">-&gt;</span> a <span class="synStatement">-&gt;</span> m a
  	<span class="synComment">-- Defined in ‘Data.Data’</span>
</pre><p>大量のメソッドが並んでいますが、キモはgfoldlとgunfoldの2つです。この2つさえ理解してしまえば残りは大したことありません。</p><p>foldlはリスト</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>[a0, a1, a2, <span class="synStatement">...</span>, an]
</pre><p>に対し、次のような操作を提供するものです</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>zero <span class="synStatement">`op`</span> a0 <span class="synStatement">`op`</span> a1 <span class="synStatement">`op`</span> a2 <span class="synStatement">`op`</span> <span class="synStatement">...</span> <span class="synStatement">`op`</span> an
</pre><p>この関数の一般化を考えてみます。一般の代数的データ型Aが以下のような値コンストラクタで定義されているとします</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>C x0 x1 x2 <span class="synStatement">...</span> xn
</pre><p>これに対して、gfoldlでは、このA型の値に</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>(zero C) <span class="synStatement">`op`</span> x0 <span class="synStatement">`op`</span> x1 <span class="synStatement">`op`</span> x2 <span class="synStatement">`op`</span> <span class="synStatement">...</span> <span class="synStatement">`op`</span> xn
</pre><p>という処理を行います。</p><br />
<p>gfoldlの型を見てみましょう</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>gfoldl
  <span class="synStatement">::</span> Data a <span class="synStatement">=&gt;</span>
     (forall d b<span class="synStatement">.</span> Data d <span class="synStatement">=&gt;</span> c (d <span class="synStatement">-&gt;</span> b) <span class="synStatement">-&gt;</span> d <span class="synStatement">-&gt;</span> c b)
     <span class="synStatement">-&gt;</span> (forall g<span class="synStatement">.</span> g <span class="synStatement">-&gt;</span> c g) <span class="synStatement">-&gt;</span> a <span class="synStatement">-&gt;</span> c a
</pre><p>Rank2の多相型になっているため見た目は少々複雑ですが、先ほど説明した動作と照らしあわせて考えてみましょう。</p><p>まずは第二引数の型について考えてみましょう。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>zero <span class="synStatement">::</span> forall g<span class="synStatement">.</span> g <span class="synStatement">-&gt;</span> c g
</pre><p>これは簡単です。値コンストラクタをApplicative的なものに包むだけの関数です。</p><p>次に、第一引数の型について考えてみます。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>op <span class="synStatement">::</span> forall d b<span class="synStatement">.</span> Data d <span class="synStatement">=&gt;</span> c (d <span class="synStatement">-&gt;</span> b) <span class="synStatement">-&gt;</span> d <span class="synStatement">-&gt;</span> c b
</pre><p>第一引数は上での説明に出てきたopの部分に相当します。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>C x0 x1 x2 <span class="synStatement">...</span> xn
</pre><p>の各xiの型がバラバラである可能性がある以上、opは十分一般的な関数でなければなりません。引数の型についての制限は、dがDataの<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9">インスタンス</a>であることだけです。しかし、Dataの<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9">インスタンス</a>である型は、その型のすべてのフィールドの型がDataの<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9">インスタンス</a>であることが要求されるため、これは問題ありません。</p><p>実際にopを適用させていった時、型がどのように変化していくか見てみましょう</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>(zero C)                 <span class="synStatement">::</span> c (T0 <span class="synStatement">-&gt;</span> T1 <span class="synStatement">-&gt;</span> T2 <span class="synStatement">-&gt;</span> <span class="synStatement">...</span> <span class="synStatement">-&gt;</span> Tn <span class="synStatement">-&gt;</span> A)
(zero C) <span class="synStatement">`op`</span> x0         <span class="synStatement">::</span> c (T1 <span class="synStatement">-&gt;</span> T2 <span class="synStatement">-&gt;</span> <span class="synStatement">...</span> <span class="synStatement">-&gt;</span> Tn <span class="synStatement">-&gt;</span> A)
(zero C) <span class="synStatement">`op`</span> x0 <span class="synStatement">`op`</span> x1 <span class="synStatement">::</span> C (T2 <span class="synStatement">-&gt;</span> <span class="synStatement">...</span> <span class="synStatement">-&gt;</span> Tn <span class="synStatement">-&gt;</span> A)
<span class="synStatement">...</span>
(zero C) <span class="synStatement">`op`</span> x0 <span class="synStatement">`op`</span> x1 <span class="synStatement">`op`</span> <span class="synStatement">...</span> <span class="synStatement">`op`</span> x(n<span class="synStatement">-</span><span class="synConstant">1</span>)         <span class="synStatement">::</span> C (Tn <span class="synStatement">-&gt;</span> A)
(zero C) <span class="synStatement">`op`</span> x0 <span class="synStatement">`op`</span> x1 <span class="synStatement">`op`</span> <span class="synStatement">...</span> <span class="synStatement">`op`</span> x(n<span class="synStatement">-</span><span class="synConstant">1</span>) <span class="synStatement">`op`</span> xn <span class="synStatement">::</span> C A
</pre><p>この操作を続けていく中で、opは型</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>c (Ti <span class="synStatement">-&gt;</span> T(i<span class="synStatement">+</span><span class="synConstant">1</span>) <span class="synStatement">-&gt;</span> <span class="synStatement">...</span> <span class="synStatement">-&gt;</span> Tn <span class="synStatement">-&gt;</span> A)
</pre><p>にフィールドの値を適用し、</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>c (T(i<span class="synStatement">+</span><span class="synConstant">1</span>) <span class="synStatement">-&gt;</span> <span class="synStatement">...</span> <span class="synStatement">-&gt;</span> Tn <span class="synStatement">-&gt;</span> A)
</pre><p>にしていることがわかります。<br />
この</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>Ti
</pre><p>の部分がdに相当し、</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>T(i<span class="synStatement">+</span><span class="synConstant">1</span>) <span class="synStatement">-&gt;</span> <span class="synStatement">...</span> <span class="synStatement">-&gt;</span> Tn <span class="synStatement">-&gt;</span> A
</pre><p>の部分がbに相当するのがお分かりでしょうか。</p><p>ここまで分かれば使うのは簡単です。実際に使ってみましょう。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synType">data</span> Person <span class="synStatement">=</span> Person {
    name <span class="synStatement">::</span> String
  , age <span class="synStatement">::</span> Int
  , isMale <span class="synStatement">::</span> Bool
  } <span class="synType">deriving</span> (Eq, Show, Data, Typeable)
</pre><p>自前で定義したPerson型に対して、gfoldlを使ってみます。<br />
一番簡単なのは、値コンストラクタに各フィールドの値を適用させていって元の値に戻すことです。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synStatement">&gt;&gt;&gt;</span> gfoldl (<span class="synStatement">\</span>(Just con) field <span class="synStatement">-&gt;</span> Just (con field)) Just <span class="synStatement">$</span> Person <span class="synConstant">&quot;Tanaka&quot;</span> <span class="synConstant">18</span> False
Just (Person {name <span class="synStatement">=</span> <span class="synConstant">&quot;Tanaka&quot;</span>, age <span class="synStatement">=</span> <span class="synConstant">18</span>, isMale <span class="synStatement">=</span> False})
</pre><p>他にも、例えばn番目のフィールドの値を取得するといったこともgfoldlならできてしまいます。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>get <span class="synStatement">::</span> forall a t<span class="synStatement">.</span> Data t <span class="synStatement">=&gt;</span> Int <span class="synStatement">-&gt;</span> t <span class="synStatement">-&gt;</span> a
get n x <span class="synStatement">=</span> result
  <span class="synType">where</span>
    (result, _, _) <span class="synStatement">=</span> gfoldl step (<span class="synStatement">\</span>con <span class="synStatement">-&gt;</span> (undefined, <span class="synConstant">0</span>, con)) x
    step <span class="synStatement">::</span> forall a d b<span class="synStatement">.</span> Data d <span class="synStatement">=&gt;</span> (a, Int, d <span class="synStatement">-&gt;</span> b) <span class="synStatement">-&gt;</span> d <span class="synStatement">-&gt;</span> (a, Int, b)
    step (res, i, con) field
      <span class="synStatement">|</span> i <span class="synStatement">==</span> n <span class="synStatement">=</span> (unsafeCoerce field, i <span class="synStatement">+</span> <span class="synConstant">1</span>, con field)
      <span class="synStatement">|</span> otherwise <span class="synStatement">=</span>  (res, i <span class="synStatement">+</span> <span class="synConstant">1</span>, con field)
</pre><p>実行例:</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synStatement">&gt;&gt;&gt;</span> <span class="synStatement">let</span> yamada <span class="synStatement">=</span> Person { name <span class="synStatement">=</span> <span class="synConstant">&quot;Yamada&quot;</span>, age <span class="synStatement">=</span> <span class="synConstant">18</span>, isMale <span class="synStatement">=</span> False }
<span class="synStatement">&gt;&gt;&gt;</span> get <span class="synConstant">0</span> yamada <span class="synStatement">::</span> String
<span class="synConstant">&quot;Yamada&quot;</span>
<span class="synStatement">&gt;&gt;&gt;</span> get <span class="synConstant">1</span> yamada <span class="synStatement">::</span> Int
<span class="synConstant">18</span>
<span class="synStatement">&gt;&gt;&gt;</span> get <span class="synConstant">2</span> yamada <span class="synStatement">::</span> Bool
False
</pre><p>ただし、戻り地の型が不定である以上、この関数の扱いには注意が必要です。<br />
間違った型を指定してしまった場合はエラーになるばかりか、最悪の場合コアダンプして死にます。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synStatement">&gt;&gt;&gt;</span> get <span class="synConstant">0</span> yamada <span class="synStatement">::</span> Int
<span class="synConstant">1729382804966730138</span>
<span class="synStatement">&gt;&gt;&gt;</span> get <span class="synConstant">0</span> yamada <span class="synStatement">::</span> IO ()
<span class="synStatement">&lt;</span>interactive<span class="synStatement">&gt;:</span> internal error<span class="synStatement">:</span> stg_ap_v_ret
    (GHC version <span class="synConstant">7.8</span><span class="synStatement">.</span><span class="synConstant">4</span> for x86_64_unknown_linux)
    Please report this as a GHC bug<span class="synStatement">:</span>  http<span class="synStatement">://</span>www<span class="synStatement">.</span>haskell<span class="synStatement">.</span>org<span class="synStatement">/</span>ghc<span class="synStatement">/</span>reportabug
中止 (コアダンプ)
</pre><p>この他にも、例えばフィールドの全型情報を取得するといったこともできます。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>getTypes <span class="synStatement">::</span> forall t<span class="synStatement">.</span> Data t <span class="synStatement">=&gt;</span> t <span class="synStatement">-&gt;</span> [TypeRep]
getTypes x <span class="synStatement">=</span> types
  <span class="synType">where</span>
    (types, _) <span class="synStatement">=</span> gfoldl step (<span class="synStatement">\</span>con <span class="synStatement">-&gt;</span> ([], con)) x
    step <span class="synStatement">::</span> forall d b<span class="synStatement">.</span> Data d <span class="synStatement">=&gt;</span> ([TypeRep], d <span class="synStatement">-&gt;</span> b) <span class="synStatement">-&gt;</span> d <span class="synStatement">-&gt;</span> ([TypeRep], b)
    step (ts, con) field <span class="synStatement">=</span> (ts <span class="synStatement">++</span> [typeOf field], con field)
</pre><p>実行例:</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synStatement">&gt;&gt;&gt;</span> getTypes yamada
[[Char],Int,Bool]
</pre><p>実は、これと同じようなことをするためのgmapQ関数というものが用意されています。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>gmapQ <span class="synStatement">::</span> Data a <span class="synStatement">=&gt;</span> (forall d<span class="synStatement">.</span> Data d <span class="synStatement">=&gt;</span> d <span class="synStatement">-&gt;</span> u) <span class="synStatement">-&gt;</span> a <span class="synStatement">-&gt;</span> [u]
<span class="synStatement">&gt;&gt;&gt;</span> gmapQ typeOf yamada
[[Char],Int,Bool]
</pre><p>この他にも用途毎にgmapT, gmapM, gmapMp等、様々なgfoldlの亜種が用意されています。このへんは適当に調べてみてください。</p><p>長くなったので続きはまた今度。次はgunfoldの型を読み解いていこうと思います。</p><p><div class="hatena-asin-detail"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4274068854/cloudear-22/"><img src="http://ecx.images-amazon.com/images/I/51P6NdS4IGL._SL160_.jpg" class="hatena-asin-detail-image" alt="すごいHaskellたのしく学ぼう!" title="すごいHaskellたのしく学ぼう!"></a><div class="hatena-asin-detail-info"><p class="hatena-asin-detail-title"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4274068854/cloudear-22/">すごいHaskellたのしく学ぼう!</a></p><ul><li><span class="hatena-asin-detail-label">作者:</span> Miran Lipovača,<a class="keyword" href="http://d.hatena.ne.jp/keyword/%C5%C4%C3%E6%B1%D1%B9%D4">田中英行</a>,村主崇行</li><li><span class="hatena-asin-detail-label">出版社/メーカー:</span> <a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AA%A1%BC%A5%E0%BC%D2">オーム社</a></li><li><span class="hatena-asin-detail-label">発売日:</span> 2012/05/23</li><li><span class="hatena-asin-detail-label">メディア:</span> 単行本（ソフトカバー）</li><li><span class="hatena-asin-detail-label">購入</span>: 25人 <span class="hatena-asin-detail-label">クリック</span>: 580回</li><li><a href="http://d.hatena.ne.jp/asin/4274068854/cloudear-22" target="_blank">この商品を含むブログ (70件) を見る</a></li></ul></div><div class="hatena-asin-detail-foot"></div></div></p>


{% endraw %}
