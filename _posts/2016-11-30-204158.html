---
layout: post
title: アドホックな多相性の実現方法いろいろ
tags:
- Others

---
{% raw %}
<p><iframe src="http://inkar-us-i.hatenablog.com/embed/2016/11/30/022452" title="OCamlのFunctorという概念を知らずに自分で再発明していた話 - きくらげ観察日記" class="embed-card embed-blogcard" scrolling="no" frameborder="0" style="display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;"></iframe><cite class="hatena-citation"><a href="/2016/11/30/022452.html">inkar-us-i.hatenablog.com</a></cite></p><br />
<p>先日<a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a>のFunctorという新たな多相性の実現方法を学んだので、せっかくなので各言語の<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A2%A5%C9%A5%DB%A5%C3%A5%AF">アドホック</a>多相性についてまとめてみたいと思います。</p><p>クラスとその継承ではなく、<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A2%A5%C9%A5%DB%A5%C3%A5%AF">アドホック</a>な方法で多相を実現する手段はいくつかありますが、その根本にあるア<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A4%A5%C7%A5%A2">イデア</a>はすべて同じです。</p><p>以下では、例としてどの言語でも、「同値比較のできる型tについて、tのリストから特定の値を探す」関数を定義します。</p>

<div class="section">
    <h3>クラスの継承による多相</h3>
    <p><a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A2%A5%C9%A5%DB%A5%C3%A5%AF">アドホック</a>な多相の話をする前に、まずは大部分の言語に存在する継承による多相を見てみましょう。</p>
<pre class="code lang-java" data-lang="java" data-unlink><span class="synPreProc">import</span> java.util.*;

<span class="synType">interface</span> Eq&lt;T&gt; {
    <span class="synType">public</span> <span class="synType">boolean</span> equalTo(T that);
}

<span class="synType">class</span> Person <span class="synType">implements</span> Eq&lt;Person&gt; {
    <span class="synComment">// 例を簡単にするために、パブリックなプロパティを用意しています</span>
    <span class="synType">public</span> String name;
    <span class="synType">public</span> <span class="synType">int</span> age;
    <span class="synType">public</span> Person(String name, <span class="synType">int</span> age) {
        <span class="synType">this</span>.name = name;
        <span class="synType">this</span>.age = age;
    }

    <span class="synType">public</span> <span class="synType">boolean</span> equalTo(Person that) {
        <span class="synStatement">if</span> (that <span class="synStatement">instanceof</span> Person) {
            Person t = (Person)that;
            <span class="synStatement">return</span> <span class="synType">this</span>.name.equals(t.name) &amp;&amp;
                <span class="synType">this</span>.age == t.age;
        } <span class="synStatement">else</span> {
            <span class="synStatement">return</span> <span class="synConstant">false</span>;
        }
    }
}

<span class="synType">class</span> Find {
    <span class="synType">public</span> <span class="synType">static</span> &lt;T <span class="synType">extends</span> Eq&lt;T&gt;&gt; T find(T e, List&lt;T&gt; xs) {
        <span class="synStatement">for</span> (T x : xs) {
            <span class="synStatement">if</span> (e.equalTo(x)) {
                <span class="synStatement">return</span> x;
            }
        }
        <span class="synStatement">return</span> <span class="synConstant">null</span>;
    }
}
</pre><p>あまり<a class="keyword" href="http://d.hatena.ne.jp/keyword/Java">Java</a>らしくないかもしれませんが、これは後にでてくる<a class="keyword" href="http://d.hatena.ne.jp/keyword/%B4%D8%BF%F4%B7%BF%B8%C0%B8%EC">関数型言語</a>との比較のためです。<br />
こういった多相性の実現方法の欠点は、Person型を作る時点でわかっているインターフェースしか実装することができないことです。<br />
Person型を作った時点ではまだEqインターフェースは存在していなく、後になってPersonの同値比較をしたくなった場合、この方法ではあらたにPersonにEqの実装を追加する方法がありません。</p>

</div>
<div class="section">
    <h3><a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A2%A5%C9%A5%DB%A5%C3%A5%AF">アドホック</a>多相の基本的なア<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A4%A5%C7%A5%A2">イデア</a></h3>
    <p>では<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A2%A5%C9%A5%DB%A5%C3%A5%AF">アドホック</a>多相ではどのように多相を実現しているかというと、多相性が必要な部分(先ほどで言えば同値比較関数)を何らかの方法で別に渡してしまおうという考え方に基づいています。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synType">data</span> Person <span class="synStatement">=</span> Person {
    name <span class="synStatement">::</span> String
  , age <span class="synStatement">::</span> Int
  }

personEq <span class="synStatement">::</span> Person <span class="synStatement">-&gt;</span> Person <span class="synStatement">-&gt;</span> Bool
personEq a b <span class="synStatement">=</span> name a <span class="synStatement">==</span> name b <span class="synStatement">&amp;&amp;</span> age a <span class="synStatement">==</span> age b

find <span class="synStatement">::</span> (a <span class="synStatement">-&gt;</span> a <span class="synStatement">-&gt;</span> Bool) <span class="synStatement">-&gt;</span> a <span class="synStatement">-&gt;</span> [a] <span class="synStatement">-&gt;</span> Maybe a
find _ _ [] <span class="synStatement">=</span> Nothing
find eq e (x <span class="synStatement">:</span> xs)
  <span class="synStatement">|</span> eq e x <span class="synStatement">=</span> Just x
  <span class="synStatement">|</span> otherwise <span class="synStatement">=</span> find eq e xs
</pre><p>このfind関数は比較方法を受け取って、その比較方法に基づいてリストの中から要素を検索しています。<br />
また、このような関数が複数存在する場合は、1つのデータ構造にまとめることも多いです。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synType">data</span> Eq a <span class="synStatement">=</span> Eq a {
  eq <span class="synStatement">::</span> a <span class="synStatement">-&gt;</span> a <span class="synStatement">-&gt;</span> Bool
  }
</pre><p>しかし、これらの関数やデータ構造を直接渡すのは面倒です。<br />
<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A2%A5%C9%A5%DB%A5%C3%A5%AF">アドホック</a>多相性を扱う方法はいくつかありますが、その方法はいずれも「このデータ構造をどれだけ簡単に渡すか」という考え方に基づいています。</p>

</div>
<div class="section">
    <h3>型クラスを使った多相性</h3>
    <p>型クラスに関する構文を言語に組み込むと、こういった多相性を簡単に実現することができます。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synType">class</span> Eq a <span class="synType">where</span>
  eq <span class="synStatement">::</span> a <span class="synStatement">-&gt;</span> a <span class="synStatement">-&gt;</span> Bool

<span class="synType">instance</span> Eq Person <span class="synType">where</span>
  eq a b <span class="synStatement">=</span> name a <span class="synStatement">==</span> name b <span class="synStatement">&amp;&amp;</span> age a <span class="synStatement">==</span> age b

find <span class="synStatement">::</span> Eq a <span class="synStatement">=&gt;</span> a <span class="synStatement">-&gt;</span> [a] <span class="synStatement">-&gt;</span> Maybe a
find _ _ [] <span class="synStatement">=</span> Nothing
find eq e (x <span class="synStatement">:</span> xs)
  <span class="synStatement">|</span> eq e x <span class="synStatement">=</span> Just x
  <span class="synStatement">|</span> otherwise <span class="synStatement">=</span> find eq e xs
</pre><p>このとき、型クラスEqのメソッドeqは、aの型によって一意的に決まります。<br />
したがって、わざわざeqを引数などで持ちまわる必要がなくなり、コードが簡潔に書けるようになります。<br />
この方法は以下で紹介する他の方法よりも簡潔に書くことができますが、型クラスCの型Tによる実装を、コード中に1種類しか持つことができないという弱点もあります。</p>

</div>
<div class="section">
    <h3>暗黙引数を使った多相性</h3>
    <p><a class="keyword" href="http://d.hatena.ne.jp/keyword/Scala">Scala</a>の型クラスはtraitを用いて実現されているとよく言われますが、本当に重要なのは暗黙引数の方です。</p>
<pre class="code lang-scala" data-lang="scala" data-unlink><span class="synType">trait</span> Eq[T] {
<span class="synIdentifier">  def</span> eq(a: T,b: T): Boolean
}

<span class="synType">case</span> <span class="synType">class</span> Person(name : <span class="synConstant">String</span>, age : Int)

<span class="synType">object</span> PersonEq <span class="synType">extends</span> Eq[Person] {
<span class="synIdentifier">  def</span> eq(a: Person, b: Person): Boolean =
    a.name == b.name &amp;&amp; a.age == b.age
}

<span class="synType">object</span> Find {
<span class="synIdentifier">  def</span> find[T](e: T, xs: List[T])(implicit E : Eq[T]): Option[T] =
    xs match {
      <span class="synType">case</span> Nil =&gt; None
      <span class="synType">case</span> x :: xs_ =&gt;
        <span class="synStatement">if</span> (E.eq(e, x))
          Some(x)
        <span class="synStatement">else</span> find(e, xs_)
    }
}
</pre><p>使う側では</p>
<pre class="code lang-scala" data-lang="scala" data-unlink>implicit <span class="synType">val</span> PEq: Eq[Person] = PersonEq
</pre><p>などとしてから、Find.findを呼びます。<br />
この暗黙引数は、別にtraitでなくても構わないわけです。例えば、次のようにfindを実装することもできます。</p>
<pre class="code lang-scala" data-lang="scala" data-unlink><span class="synIdentifier">  def</span> find2[T](e: T, xs: List[T])(implicit eq: (T, T) =&gt; Boolean): Option[T] =
    xs match {
      <span class="synType">case</span> Nil =&gt; None
      <span class="synType">case</span> x :: xs_ =&gt;
        <span class="synStatement">if</span> (eq(e, x))
          Some(x)
        <span class="synStatement">else</span> find2(e, xs_)
    }
</pre><p>何にせよ、この暗黙引数という機能があるおかげで、使う側では一々</p>
<pre class="code lang-scala" data-lang="scala" data-unlink>Find.find(e, xs)(PersonEq)
</pre><p>などというように書かなくても良くなるわけです。<br />
この方法は状況に合わせてEq[Person]を様々にカスタマイズできるという点で<a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a>の型クラスより柔軟性が高いですが、暗黙引数というかなり大きなものを言語仕様に組み込んでしまったため、変な書き方をすれば一気にコードがわけのわからないものになってしまうというデメリットもあります。</p>

</div>
<div class="section">
    <h3>Functorを使う</h3>
    <p><a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a>の<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A2%A5%C9%A5%DB%A5%C3%A5%AF">アドホック</a>多相性の実現方法は大胆で、なんと「モジュール単位で引数を受け取ってしまおう」という考え方に基づいています。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>(<span class="synStatement">*</span>
 <span class="synStatement">*</span> モジュールの「型」を定義
 <span class="synStatement">*</span> モジュールであることを除けば、Scalaのtraitの定義に近い
 <span class="synStatement">*</span>)
<span class="synType">module</span> <span class="synType">type</span> Eq <span class="synStatement">=</span>
  sig
    <span class="synType">type</span> a
    val eq <span class="synStatement">:</span> a <span class="synStatement">-&gt;</span> a <span class="synStatement">-&gt;</span> bool
  end

<span class="synType">type</span> person <span class="synStatement">=</span>
  <span class="synStatement">|</span> Person <span class="synStatement">of</span> string <span class="synStatement">*</span> int

<span class="synType">module</span> PersonEq <span class="synStatement">:</span> (Eq with <span class="synType">type</span> a <span class="synStatement">=</span> person) <span class="synStatement">=</span>
  struct
    <span class="synType">type</span> a <span class="synStatement">=</span> person
    <span class="synStatement">let</span> eq a b <span class="synStatement">=</span> match (a, b) with
      <span class="synStatement">|</span> (Person(a_name, a_age), Person(b_name, b_age)) <span class="synStatement">-&gt;</span>
         a_name <span class="synStatement">=</span> b_name <span class="synStatement">&amp;&amp;</span> a_age <span class="synStatement">=</span> b_age
  end

<span class="synType">module</span> <span class="synType">type</span> Find <span class="synStatement">=</span>
  sig
    <span class="synType">type</span> a
    val find <span class="synStatement">:</span> a <span class="synStatement">-&gt;</span> a list <span class="synStatement">-&gt;</span> a option
  end

<span class="synType">module</span> Find (E <span class="synStatement">:</span> Eq) <span class="synStatement">:</span> (Find with <span class="synType">type</span> a <span class="synStatement">=</span> E.a) <span class="synStatement">=</span>
  struct
    <span class="synType">type</span> a <span class="synStatement">=</span> E.a
    <span class="synStatement">let</span> rec find (e <span class="synStatement">:</span> a) (xs <span class="synStatement">:</span> a list) <span class="synStatement">:</span> a option <span class="synStatement">=</span>
      match xs with
      <span class="synStatement">|</span> [] <span class="synStatement">-&gt;</span> None
      <span class="synStatement">|</span> x <span class="synStatement">::</span> xs' <span class="synStatement">-&gt;</span>
         <span class="synStatement">if</span> E.eq e x
         <span class="synStatement">then</span> Some(x)
         <span class="synStatement">else</span> find e xs'
  end
</pre><p>最後に定義したモジュールFindは、module type Eqに属するモジュールを受け取り、findが定義されたモジュールを返すという「関数」のようなものになっています。<br />
モジュール単位でEqを受け取れば、その中にある関数では一々Eqを引数に取らなくても大丈夫、という考え方です。<br />
<a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a>と違って一つの型のEqの実装を複数用意できますし、一旦モジュールの引数に型クラスの実装を渡してしまえば、内部の関数に渡す必要はなくなります。</p>

</div>

{% endraw %}
