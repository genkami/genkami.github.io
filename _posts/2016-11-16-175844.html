---
layout: post
title: Coqで「任意のxについて…」「あるxが存在して…」を扱う
tags:
- Coq

---
{% raw %}
<p>Coqで「任意のxについて…」を表すforall xは、xを受け取って残りの命題の証明を返す関数となっています。</p>
<pre class="code" data-lang="" data-unlink>Definition prop_1 : forall (x : nat), x = x :=
  fun x =&gt; eq_refl x.</pre><p>また、「あるxが存在して…」を表すexists xは、以下のようなデータ型として定義されています。</p>
<pre class="code" data-lang="" data-unlink>Inductive ex (A:Type) (P:A -&gt; Prop) : Prop :=
  ex_intro : forall x:A, P x -&gt; ex (A:=A) P.</pre>
<div class="section">
    <h3>結論がforall x, ...である命題を証明する</h3>
    <p>introsタクティックを使うと、forallの部分が外れます。</p>
<pre class="code" data-lang="" data-unlink>Goal forall x : nat, x = x.
Proof.
  intros x. (* x : nat, Goal: x = x *)
  reflexivity.
Qed.</pre>
</div>
<div class="section">
    <h3>前提のforallを具体的な値に変換する</h3>
    <p>specializeタクティックを使うと、forall x, ...のxを具体的な値で置き換えることができます。</p>
<pre class="code" data-lang="" data-unlink>Goal forall P : nat -&gt; Prop,
       (forall x, P x) -&gt; P 5.
Proof.
  intros P H. (* H : forall x : nat, P x *)
  specialize (H 5). (* H : P 5 *)
  assumption.
Qed.</pre>
</div>
<div class="section">
    <h3>結論がexists x, ...である命題を証明する</h3>
    <p>一番基本的な方法は、上のコンストラクタex_introをそのまま使うことです。</p>
<pre class="code" data-lang="" data-unlink>Goal exists (x : nat), x = 0.
Proof.
  (* ex_intro : forall x : A, P x -&gt; ex (A := A) P のxに0を与える *)
  apply ex_intro with (x := 0).
  (* Goal: 0 = 0 *)
  apply eq_refl.
Qed.</pre><p>これと同等なことを行うためのタクティックとして、existsというものが存在します。</p>
<pre class="code" data-lang="" data-unlink>Goal exists (x : nat), 1 + 1 = x.
Proof.
  (* 「あるx」の「x」は2だよ、ということを教える *)
  exists 2.
  reflexivity.
Qed.</pre>
</div>
<div class="section">
    <h3>前提のexists x, ...からxの値を取り出す</h3>
    <p>existsはただのデータ構造なので、destructを使うと変数を取り出すことができるようになります。</p>
<pre class="code" data-lang="" data-unlink>Goal forall (x : nat) (P : nat -&gt; nat -&gt; Prop),
       (forall a b : nat, P a b -&gt; P b a) -&gt;
       (exists y : nat, P x y) -&gt;
       (exists z : nat, P z x).
Proof.
  intros x P H0 H1.
  (* H0 : forall a b : nat, P a b -&gt; P b a *)
  (* H1 : exists y : nat, P x y *)
  (* Goal: exists z : nat, P z x *)
  destruct H1.
  (*
   *  H が具体化されて、
   * x0 : nat, H : P x x0
   * の2つになる
   *)
  specialize (H0 x x0).
  (* H0 : P x x0 -&gt; P x0 x *)
  apply H0 in H.
  (* H : P x0 x *)
  exists x0.
  (* Goal : P x0 x *)
  assumption.
Qed.</pre>
</div>

{% endraw %}
