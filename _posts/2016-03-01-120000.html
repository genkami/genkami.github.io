---
layout: post
title: ScalaFX&#58; TaskとService
tags:
- Scala

---
{% raw %}
<p><a class="keyword" href="http://d.hatena.ne.jp/keyword/JavaFX">JavaFX</a>では別スレッドで作業を行うためにTaskとServiceという2つのクラスを提供しています。<br />
ScalaFXでも同名のクラスは用意されているのですが、その<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%B9%A5%C8%A5%E9%A5%AF%A5%BF">コンストラクタ</a>の定義を見てみると</p>
<pre class="code lang-scala" data-lang="scala" data-unlink><span class="synStatement">new</span> Task(delegate: javafx.concurrent.Task[T])
<span class="synStatement">new</span> Service(delegate: javafx.concurrent.Service[T])
</pre><p>となっており、実質<a class="keyword" href="http://d.hatena.ne.jp/keyword/JavaFX">JavaFX</a>のものを使うしかない状態です。</p><p>また、ScalaFX(<a class="keyword" href="http://d.hatena.ne.jp/keyword/JavaFX">JavaFX</a>)ではUI部分の変更はメインとなるスレッド(アプリケーションスレッド)でしか実行できないため、Taskを実行する上では注意が必要です。</p>

<div class="section">
    <h3><a class="keyword" href="http://d.hatena.ne.jp/keyword/javafx">javafx</a>.concurrent.Task</h3>
    <p>Taskは、1回きりの使い捨てとなるスレッドを生成するためのクラスです。抽象<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E1%A5%BD%A5%C3%A5%C9">メソッド</a>であるcall()をオーバーライドすることによって、その<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E1%A5%BD%A5%C3%A5%C9">メソッド</a>が外部スレッドで行われるようになります。<br />
ただし、call()が成功した際に実行されるsucceeded()や、失敗した場合に呼ばれるfailed()等はアプリケーションスレッドから実行されるので、UI部分の操作等はこの<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E1%A5%BD%A5%C3%A5%C9">メソッド</a>から行うとよいです。</p><p>また、アプリケーションスレッドと通信するための手段として、進捗状況を表すprogress, タスクの状態を表すstate, タスクの実行結果を表すvalue等のプロパティが用意されています。</p>

</div>
<div class="section">
    <h3>Service</h3>
    <p>Serviceクラスは何度も実行される想定の動作のためのクラスです。<br />
ユーザーがオーバーライドするのはcreateTask()<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E1%A5%BD%A5%C3%A5%C9">メソッド</a>で、この<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E1%A5%BD%A5%C3%A5%C9">メソッド</a>を呼ぶ度に次に実行すべき動作をTaskの形で返します。Service.restart()が呼ばれる度にこのcreateTask()が呼ばれ、生成されたTaskのcall()が別スレッドで呼ばれます。</p>

</div>
<div class="section">
    <h3>サンプル</h3>
    <pre class="code lang-scala" data-lang="scala" data-unlink><span class="synPreProc">import</span> scala.annotation.tailrec
<span class="synPreProc">import</span> scalafx.Includes._
<span class="synPreProc">import</span> scalafx.application.JFXApp
<span class="synPreProc">import</span> scalafx.application.JFXApp.PrimaryStage
<span class="synPreProc">import</span> scalafx.geometry.{NodeOrientation, Insets}
<span class="synPreProc">import</span> scalafx.scene.Scene
<span class="synPreProc">import</span> scalafx.scene.control.{Button, Label, ProgressBar}
<span class="synPreProc">import</span> scalafx.scene.input.MouseEvent
<span class="synPreProc">import</span> scalafx.scene.layout.{HBox, VBox}
<span class="synPreProc">import</span> scalafx.concurrent.Service
<span class="synPreProc">import</span> javafx.concurrent.{Service =&gt; JService, Task =&gt; JTask}

<span class="synType">class</span> Counter <span class="synType">extends</span> JService[Unit] {
  <span class="synType">override</span> <span class="synType">protected</span><span class="synIdentifier"> def</span> createTask() = <span class="synStatement">new</span> JTask[Unit]() {
    <span class="synType">override</span> <span class="synType">protected</span><span class="synIdentifier"> def</span> call() {
      @tailrec<span class="synIdentifier"> def</span> iterate(i: Int) {
        <span class="synStatement">if</span> (i &gt;= <span class="synConstant">100</span> || isCancelled) {
          <span class="synComment">// break</span>
        } <span class="synStatement">else</span> {
          Thread.sleep(<span class="synConstant">100</span>)
          updateProgress(i, <span class="synConstant">100</span>)
          iterate(i + <span class="synConstant">1</span>)
        }
      }
      iterate(<span class="synConstant">0</span>)
    }
  }
}
<span class="synType">object</span> TaskAndService <span class="synType">extends</span> JFXApp {
  <span class="synType">val</span> counter: Service[Unit] = <span class="synStatement">new</span> Counter()
  stage = <span class="synStatement">new</span> PrimaryStage {
    title = <span class="synConstant">&quot;task and service&quot;</span>
    scene = <span class="synStatement">new</span> Scene {
      root = <span class="synStatement">new</span> VBox {
        padding = Insets(<span class="synConstant">10</span>)
        spacing = <span class="synConstant">5</span>
        children = Seq(
          <span class="synStatement">new</span> HBox {
            spacing = <span class="synConstant">5</span>
            children = Seq(
              <span class="synStatement">new</span> Label(<span class="synConstant">&quot;Progress: &quot;</span>),
              <span class="synStatement">new</span> ProgressBar {
                progress &lt;== counter.progress
              }
            )
          },
          <span class="synStatement">new</span> HBox {
            nodeOrientation = NodeOrientation.RIGHT_TO_LEFT
            children = <span class="synStatement">new</span> Button {
              text = <span class="synConstant">&quot;Run!&quot;</span>
              onMouseClicked = (ev: MouseEvent) =&gt; {
                <span class="synStatement">if</span> (!counter.running())
                  counter.restart()
              }
            }
          }
        )
      }
    }
  }
}
</pre>
</div>
<div class="section">
    <h3>実行例</h3>
    <p><span itemscope itemtype="http://schema.org/Photograph"><img src="/img/post/2016-03-01-http-cdn-ak.f.st-hatena.com-images-fotolife-c-cloudear8-20160227-20160227030847.png" alt="f:id:cloudear8:20160227030847p:plain" title="f:id:cloudear8:20160227030847p:plain" class="hatena-fotolife" itemprop="image"></span><br />
「Run!」ボタンをクリックする毎に<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%EC%A5%B9%A5%D0%A1%BC">プログレスバー</a>が初期化され、10秒間かけて100%まで進みます。</p><p><div class="hatena-asin-detail"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4864873798/cloudear-22/"><img src="http://ecx.images-amazon.com/images/I/41Rr1Iv8lhL._SL160_.jpg" class="hatena-asin-detail-image" alt="Scalaファンクショナルデザイン ―関数型プログラミングの設計と理解" title="Scalaファンクショナルデザイン ―関数型プログラミングの設計と理解"></a><div class="hatena-asin-detail-info"><p class="hatena-asin-detail-title"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4864873798/cloudear-22/">Scalaファンクショナルデザイン ―関数型プログラミングの設計と理解</a></p><ul><li><span class="hatena-asin-detail-label">作者:</span> 深井裕二</li><li><span class="hatena-asin-detail-label">出版社/メーカー:</span> 三恵社</li><li><span class="hatena-asin-detail-label">発売日:</span> 2015/05/29</li><li><span class="hatena-asin-detail-label">メディア:</span> 単行本（ソフトカバー）</li><li><a href="http://d.hatena.ne.jp/asin/4864873798/cloudear-22" target="_blank">この商品を含むブログを見る</a></li></ul></div><div class="hatena-asin-detail-foot"></div></div><div class="hatena-asin-detail"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4877833765/cloudear-22/"><img src="http://ecx.images-amazon.com/images/I/51sqlqiwgpL._SL160_.jpg" class="hatena-asin-detail-image" alt="JavaFX & Java8プログラミング―Javaによる新しいGUIプログラミング入門" title="JavaFX & Java8プログラミング―Javaによる新しいGUIプログラミング入門"></a><div class="hatena-asin-detail-info"><p class="hatena-asin-detail-title"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4877833765/cloudear-22/">JavaFX & Java8プログラミング―Javaによる新しいGUIプログラミング入門</a></p><ul><li><span class="hatena-asin-detail-label">作者:</span> 日向俊二</li><li><span class="hatena-asin-detail-label">出版社/メーカー:</span> カットシステム</li><li><span class="hatena-asin-detail-label">発売日:</span> 2015/08</li><li><span class="hatena-asin-detail-label">メディア:</span> 単行本</li><li><a href="http://d.hatena.ne.jp/asin/4877833765/cloudear-22" target="_blank">この商品を含むブログを見る</a></li></ul></div><div class="hatena-asin-detail-foot"></div></div></p>

</div>

{% endraw %}
