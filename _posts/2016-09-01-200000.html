---
layout: post
title: Gaucheでモナド その3
tags:
- Gauche

---
{% raw %}
<p><a href="/2016/08/27/200000.html">/2016/08/27/200000.html</a><cite class="hatena-citation"><a href="/2016/08/27/200000.html">inkar-us-i.hatenablog.com</a></cite></p><p>上の記事で作った<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>はグローバルなスタックに現在の<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>を積むというものでしたので、mlet*の終了と同時に現在使用している<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>に関する情報が消滅してしまい、実際の評価が後で行われるState<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>のような<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>を作ることはできませんでした。</p><p>そこで、今回は<a class="keyword" href="http://d.hatena.ne.jp/keyword/Scala">Scala</a>ライクに暗黙引数を使って<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>を作ります。</p><p><a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>自体の定義は前回と同様です。</p>
<pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synSpecial">(</span>define-class <span class="synConstant">&lt;monad&gt;</span> <span class="synSpecial">()</span>
  <span class="synSpecial">((</span>return :init-keyword :return :getter monad-return<span class="synSpecial">)</span>
   <span class="synSpecial">(</span>bind :init-keyword :bind :getter monad-bind<span class="synSpecial">)))</span>
</pre><pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synSpecial">(</span>define-macro <span class="synSpecial">(</span>defun/monad mproc args <span class="synSpecial">.</span> body<span class="synSpecial">)</span>
  <span class="synSpecial">(</span><span class="synStatement">define</span> mproc/monad
    <span class="synSpecial">(</span><span class="synIdentifier">string-&gt;symbol</span> <span class="synSpecial">(</span><span class="synIdentifier">string-append</span> <span class="synSpecial">(</span><span class="synIdentifier">symbol-&gt;string</span> mproc<span class="synSpecial">)</span> <span class="synConstant">&quot;/monad&quot;</span><span class="synSpecial">)))</span>
  <span class="synSpecial">`(</span>begin
     <span class="synSpecial">(</span>define <span class="synSpecial">,</span>mproc/monad
       <span class="synSpecial">(</span>^<span class="synSpecial">(</span>?monad<span class="synSpecial">)</span>
         <span class="synSpecial">(</span>^<span class="synSpecial">(,@</span>args<span class="synSpecial">)</span>
           <span class="synSpecial">,@</span>body<span class="synSpecial">)))</span>
     <span class="synSpecial">(</span>define-macro <span class="synSpecial">(,</span>mproc <span class="synSpecial">.</span> args<span class="synSpecial">)</span>
       <span class="synSpecial">`((,,</span>mproc/monad ?monad<span class="synSpecial">)</span> <span class="synSpecial">,@</span>args<span class="synSpecial">))))</span>
</pre><p>このマクロdefun/<a class="keyword" href="http://d.hatena.ne.jp/keyword/monad">monad</a>が今回のキモです。このマクロを使って、例えば</p>
<pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synSpecial">(</span>defun/monad mreturn <span class="synSpecial">(</span>x<span class="synSpecial">)</span>
  <span class="synSpecial">((</span>monad-return ?monad<span class="synSpecial">)</span> x<span class="synSpecial">))</span>
</pre><p>というようにreturn文mreturnを定義すると、これが以下のように展開されます。</p>
<pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synSpecial">(</span><span class="synStatement">define</span> <span class="synSpecial">(</span>mreturn/monad ?monad<span class="synSpecial">)</span>
  <span class="synSpecial">(</span>^<span class="synSpecial">(</span>x<span class="synSpecial">)</span>
    <span class="synSpecial">((</span>monad-return ?monad<span class="synSpecial">)</span> x<span class="synSpecial">)))</span>

<span class="synSpecial">(</span>define-macro <span class="synSpecial">(</span>mreturn x<span class="synSpecial">)</span>
  <span class="synSpecial">((</span>mreturn/monad ?monad<span class="synSpecial">)</span> x<span class="synSpecial">)</span>
</pre><p>mreturn/<a class="keyword" href="http://d.hatena.ne.jp/keyword/monad">monad</a>がreturnの本体で、<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>?<a class="keyword" href="http://d.hatena.ne.jp/keyword/monad">monad</a>と引数xを受け取り、xを<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>に包んで返す関数となっています。</p><p>mreturnはmreturn/<a class="keyword" href="http://d.hatena.ne.jp/keyword/monad">monad</a>を呼び出すためのマクロで、現在のスコープにある?<a class="keyword" href="http://d.hatena.ne.jp/keyword/monad">monad</a>を捕まえて、mreturn/<a class="keyword" href="http://d.hatena.ne.jp/keyword/monad">monad</a>に暗黙的に渡すようになっています。<br />
暗黙引数の頭に?が付いているのは<a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a>を参考にしました。</p><p>これを使って同様に>>=に相当する関数mbindを定義します。</p>
<pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synSpecial">(</span>defun/monad mbind <span class="synSpecial">(</span>x f<span class="synSpecial">)</span>
  <span class="synSpecial">((</span>monad-bind ?monad<span class="synSpecial">)</span> x f<span class="synSpecial">))</span>
</pre><p>また、defun/<a class="keyword" href="http://d.hatena.ne.jp/keyword/monad">monad</a>を使えば、任意の<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>に対する操作も簡単に定義することができます。</p>
<pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synSpecial">(</span>defun/monad mfor <span class="synSpecial">(</span>lst action<span class="synSpecial">)</span>
  <span class="synSpecial">(</span><span class="synStatement">if</span> <span class="synSpecial">(</span><span class="synIdentifier">null?</span> lst<span class="synSpecial">)</span>
      <span class="synSpecial">(</span>mreturn <span class="synSpecial">())</span>
      <span class="synSpecial">(</span>mlet* <span class="synSpecial">((</span>x <span class="synSpecial">(</span>action <span class="synSpecial">(</span><span class="synIdentifier">car</span> lst<span class="synSpecial">)))</span>
              <span class="synSpecial">(</span>xs <span class="synSpecial">((</span>mfor/monad ?monad<span class="synSpecial">)</span> <span class="synSpecial">(</span><span class="synIdentifier">cdr</span> lst<span class="synSpecial">)</span> action<span class="synSpecial">)))</span>
             <span class="synSpecial">(</span>mreturn <span class="synSpecial">(</span><span class="synIdentifier">cons</span> x xs<span class="synSpecial">)))))</span>
</pre><p><a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>が暗黙的に受け取れるようになったため、mlet*は<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>を引数に取らなくてもよくなります。</p>
<pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synSpecial">(</span><span class="synStatement">define-syntax</span> mlet1
  <span class="synSpecial">(</span><span class="synStatement">syntax-rules</span> <span class="synSpecial">()</span>
    <span class="synSpecial">((</span>_ var mexpr body<span class="synSpecial">)</span>
     <span class="synSpecial">(</span>mbind mexpr <span class="synSpecial">(</span>^<span class="synSpecial">(</span>var<span class="synSpecial">)</span> body<span class="synSpecial">)))</span>
    <span class="synSpecial">((</span>_ var mexpr body ...<span class="synSpecial">)</span>
     <span class="synSpecial">(</span>mbind mexpr <span class="synSpecial">(</span>^<span class="synSpecial">(</span>var<span class="synSpecial">)</span> <span class="synSpecial">(</span>mlet1 _ body ...<span class="synSpecial">))))))</span>

<span class="synSpecial">(</span><span class="synStatement">define-syntax</span> mlet*
  <span class="synSpecial">(</span><span class="synStatement">syntax-rules</span> <span class="synSpecial">()</span>
    <span class="synSpecial">((</span>_ <span class="synSpecial">()</span> body<span class="synSpecial">)</span> body<span class="synSpecial">)</span>
    <span class="synSpecial">((</span>_ <span class="synSpecial">()</span> body body2 rest ...<span class="synSpecial">)</span>
     <span class="synSpecial">(</span>mlet1 _ body body2 rest ...<span class="synSpecial">))</span>
    <span class="synSpecial">((</span>_ <span class="synSpecial">((</span>name mexpr<span class="synSpecial">)</span> binds ...<span class="synSpecial">)</span> body ...<span class="synSpecial">)</span>
     <span class="synSpecial">(</span>mlet1 name mexpr
       <span class="synSpecial">(</span>mlet* <span class="synSpecial">(</span>binds ...<span class="synSpecial">)</span> body ...<span class="synSpecial">)))))</span>
</pre><p>これを使って実際に<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>を動かしてみましょう。まずは前の例と全く同様の<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%EA%A5%B9%A5%C8%A5%E2">リストモ</a>ナド、Maybe<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>です。</p>
<pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synComment">;; リストモナド</span>
<span class="synSpecial">(</span><span class="synStatement">define</span> list-monad
  <span class="synSpecial">(</span>make <span class="synConstant">&lt;monad&gt;</span>
    :return <span class="synIdentifier">list</span>
    :bind <span class="synSpecial">(</span>^<span class="synSpecial">(</span>xs f<span class="synSpecial">)</span> <span class="synSpecial">(</span>concatenate <span class="synSpecial">(</span><span class="synIdentifier">map</span> f xs<span class="synSpecial">)))))</span>

<span class="synComment">;; Maybeモナド(というかand-letモナド)</span>
<span class="synSpecial">(</span><span class="synStatement">define</span> maybe-monad
  <span class="synSpecial">(</span>make <span class="synConstant">&lt;monad&gt;</span>
    :return identity
    :bind <span class="synSpecial">(</span>^<span class="synSpecial">(</span>mvalue f<span class="synSpecial">)</span> <span class="synSpecial">(</span><span class="synStatement">if</span> <span class="synSpecial">(</span><span class="synIdentifier">eq?</span> mvalue <span class="synConstant">#f</span><span class="synSpecial">)</span> <span class="synConstant">#f</span> <span class="synSpecial">(</span>f mvalue<span class="synSpecial">)))))</span>

<span class="synSpecial">(</span><span class="synStatement">let</span> <span class="synSpecial">((</span>?monad list-monad<span class="synSpecial">))</span>
  <span class="synSpecial">(</span>mlet*
   <span class="synSpecial">((</span>x <span class="synSpecial">'(</span><span class="synConstant">1</span> <span class="synConstant">2</span> <span class="synConstant">3</span> <span class="synConstant">4</span> <span class="synConstant">5</span><span class="synSpecial">))</span>
    <span class="synSpecial">(</span>y <span class="synSpecial">'(</span><span class="synConstant">2</span> <span class="synConstant">4</span> <span class="synConstant">6</span> <span class="synConstant">8</span> <span class="synConstant">9</span><span class="synSpecial">)))</span>
   <span class="synSpecial">(</span>mreturn <span class="synSpecial">(</span><span class="synIdentifier">cons</span> x y<span class="synSpecial">))))</span>
<span class="synComment">;; =&gt;</span>
<span class="synComment">;; ((1 . 2) (1 . 4) (1 . 6) (1 . 8) (1 . 9)</span>
<span class="synComment">;;  (2 . 2) (2 . 4) (2 . 6) (2 . 8) (2 . 9)</span>
<span class="synComment">;;  (3 . 2) (3 . 4) (3 . 6) (3 . 8) (3 . 9)</span>
<span class="synComment">;;  (4 . 2) (4 . 4) (4 . 6) (4 . 8) (4 . 9)</span>
<span class="synComment">;;  (5 . 2) (5 . 4) (5 . 6) (5 . 8) (5 . 9))</span>

<span class="synSpecial">(</span><span class="synStatement">let</span> <span class="synSpecial">((</span>?monad maybe-monad<span class="synSpecial">))</span>
  <span class="synSpecial">(</span>mlet*
   <span class="synSpecial">((</span>x <span class="synConstant">1</span><span class="synSpecial">)</span>
    <span class="synSpecial">(</span>y <span class="synConstant">2</span><span class="synSpecial">))</span>
   <span class="synSpecial">(</span>mreturn <span class="synSpecial">(</span><span class="synIdentifier">+</span> x y<span class="synSpecial">))))</span>
<span class="synComment">;; =&gt; 3</span>

<span class="synSpecial">(</span><span class="synStatement">let</span> <span class="synSpecial">((</span>?monad  maybe-monad<span class="synSpecial">))</span>
  <span class="synSpecial">(</span>mlet*
   <span class="synSpecial">((</span>x <span class="synConstant">#f</span><span class="synSpecial">)</span>
    <span class="synSpecial">(</span>y <span class="synConstant">2</span><span class="synSpecial">))</span>
   <span class="synSpecial">(</span>mreturn <span class="synSpecial">(</span><span class="synIdentifier">+</span> x y<span class="synSpecial">))))</span>
<span class="synComment">;; =&gt; #f</span>
</pre><p><a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>を現在のスコープに束縛するようになったので、State<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>を作ることもできます。</p>
<pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synSpecial">(</span><span class="synStatement">define</span> <span class="synSpecial">(</span>state-return x<span class="synSpecial">)</span>
  <span class="synSpecial">(</span>^<span class="synSpecial">(</span>s<span class="synSpecial">)</span> <span class="synSpecial">(</span><span class="synIdentifier">cons</span> x s<span class="synSpecial">)))</span>

<span class="synSpecial">(</span><span class="synStatement">define</span> <span class="synSpecial">(</span>state-bind mx f<span class="synSpecial">)</span>
  <span class="synSpecial">(</span>^<span class="synSpecial">(</span>s<span class="synSpecial">)</span>
    <span class="synSpecial">(</span><span class="synStatement">let*</span> <span class="synSpecial">((</span>res1 <span class="synSpecial">(</span>mx s<span class="synSpecial">))</span>
           <span class="synSpecial">(</span>x1 <span class="synSpecial">(</span><span class="synIdentifier">car</span> res1<span class="synSpecial">))</span>
           <span class="synSpecial">(</span>s1 <span class="synSpecial">(</span><span class="synIdentifier">cdr</span> res1<span class="synSpecial">)))</span>
      <span class="synSpecial">((</span>f x1<span class="synSpecial">)</span> s1<span class="synSpecial">))))</span>

<span class="synSpecial">(</span><span class="synStatement">define</span> state-monad
  <span class="synSpecial">(</span>make <span class="synConstant">&lt;monad&gt;</span>
    :return state-return
    :bind state-bind<span class="synSpecial">))</span>

<span class="synSpecial">(</span><span class="synStatement">define</span> <span class="synSpecial">(</span>state-get<span class="synSpecial">)</span>
  <span class="synSpecial">(</span><span class="synStatement">define</span> <span class="synSpecial">(</span>state-get-inner s<span class="synSpecial">)</span>
    <span class="synSpecial">(</span><span class="synIdentifier">cons</span> s s<span class="synSpecial">))</span>
  state-get-inner<span class="synSpecial">)</span>

<span class="synSpecial">(</span><span class="synStatement">define</span> <span class="synSpecial">(</span>state-put s<span class="synSpecial">)</span>
  <span class="synSpecial">(</span><span class="synStatement">define</span> <span class="synSpecial">(</span>state-put-inner _<span class="synSpecial">)</span>
    <span class="synSpecial">(</span><span class="synIdentifier">cons</span> <span class="synConstant">#f</span> s<span class="synSpecial">))</span>
  state-put-inner<span class="synSpecial">)</span>

<span class="synSpecial">(</span><span class="synStatement">define</span> <span class="synSpecial">(</span>state-modify f<span class="synSpecial">)</span>
  <span class="synSpecial">(</span>state-bind <span class="synSpecial">(</span>state-get<span class="synSpecial">)</span>
              <span class="synSpecial">(</span>^<span class="synSpecial">(</span>s<span class="synSpecial">)</span> <span class="synSpecial">(</span>state-put <span class="synSpecial">(</span>f s<span class="synSpecial">)))))</span>
</pre><p>実際に実行してみましょう。以下の例は、現在の状態をそのまま返しつつ、状態に1を足すアクションです。<br />
初期状態には5が与えられています。</p>
<pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synSpecial">(</span><span class="synStatement">let</span> <span class="synSpecial">((</span>?monad state-monad<span class="synSpecial">))</span>
  <span class="synSpecial">((</span>mlet*
    <span class="synSpecial">((</span>s <span class="synSpecial">(</span>state-get<span class="synSpecial">)))</span>
    <span class="synSpecial">(</span>state-put <span class="synSpecial">(</span><span class="synIdentifier">+</span> s <span class="synConstant">1</span><span class="synSpecial">))</span>
    <span class="synSpecial">(</span>mreturn s<span class="synSpecial">))</span>
   <span class="synConstant">5</span> <span class="synComment">;; (mlet* ..)の結果は関数となり、初期状態を引数として与える</span>
   <span class="synSpecial">))</span>
<span class="synComment">;; =&gt; (5 . 6)</span>
</pre><p>先ほど定義したmforを使うこともできます。以下は与えられた状態に0, .., 4を足すアクションです。</p>
<pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synSpecial">(</span><span class="synStatement">let</span> <span class="synSpecial">((</span>?monad state-monad<span class="synSpecial">))</span>
  <span class="synSpecial">((</span>mlet*
    <span class="synSpecial">()</span>
    <span class="synSpecial">(</span>mfor
     <span class="synSpecial">(</span>iota <span class="synConstant">5</span><span class="synSpecial">)</span>
     <span class="synSpecial">(</span>^<span class="synSpecial">(</span>i<span class="synSpecial">)</span>
       <span class="synSpecial">(</span>state-modify <span class="synSpecial">(</span>pa$ <span class="synIdentifier">+</span> i<span class="synSpecial">)))))</span>
   <span class="synConstant">0</span><span class="synSpecial">))</span>
<span class="synComment">;; =&gt; ((#f #f #f #f #f) . 10)</span>
</pre>

{% endraw %}
