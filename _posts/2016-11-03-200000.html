---
layout: post
title: Gaucheでロード時定数を作る
tags:
- Gauche

---
{% raw %}
<p><a class="keyword" href="http://d.hatena.ne.jp/keyword/Gauche">Gauche</a>には元々ロード時定数という機能はありませんが、マクロを使ってうまいこと頑張ると作ることができます。</p>
<pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synComment">;; ロード時定数を保存するためのモジュール</span>
<span class="synSpecial">(</span>define-module <span class="synConstant">*constant-table*</span><span class="synSpecial">)</span>

<span class="synComment">;; モジュール module の中で expr を評価し、 *constant-table* に保存</span>
<span class="synComment">;; この位置にある式を保存された値の読み出しに置き換える。</span>
<span class="synSpecial">(</span>define-macro <span class="synSpecial">(</span>load-time-constant module expr<span class="synSpecial">)</span>
  <span class="synSpecial">(</span><span class="synStatement">define</span> new-var <span class="synSpecial">(</span>gensym<span class="synSpecial">))</span>
  <span class="synSpecial">(</span>with-module <span class="synConstant">*constant-table*</span>
    <span class="synSpecial">(</span><span class="synIdentifier">eval</span> <span class="synSpecial">`(</span>define <span class="synSpecial">,</span>new-var
             <span class="synSpecial">(</span>with-module <span class="synSpecial">,</span>module <span class="synSpecial">(</span>eval <span class="synSpecial">,</span>expr <span class="synSpecial">(</span>current-module<span class="synSpecial">))))</span>
          <span class="synSpecial">(</span>current-module<span class="synSpecial">)))</span>
  <span class="synSpecial">`(</span>with-module <span class="synConstant">*constant-table*</span> <span class="synSpecial">,</span>new-var<span class="synSpecial">))</span>
</pre><p>このマクロのキモは、頑張って色々な環境を引っ張り回してevalしまくっている所です。<br />
ロード時定数なのでletの中のローカル変数などは見ることができませんが、第一引数に指定したモジュールの環境でexprを評価し、その計算結果を保持することができます。</p><br />
<p>では、実際にこのマクロがどのように動くか見てみましょう。</p>
<pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synSpecial">(</span>use math.prime<span class="synSpecial">)</span>
<span class="synComment">;; math.prime の *primes* は遅延リストであり、</span>
<span class="synComment">;; n 番目の要素が必要になった時に値が計算される。</span>

<span class="synSpecial">(</span><span class="synStatement">define</span> <span class="synSpecial">(</span>do-something-with-large-prime<span class="synSpecial">)</span>
  <span class="synSpecial">(</span>let1 p <span class="synSpecial">(</span><span class="synIdentifier">car</span> <span class="synSpecial">(</span>drop <span class="synConstant">*primes*</span> <span class="synConstant">7000000</span><span class="synSpecial">))</span> <span class="synComment">; ここで *primes* が計算される</span>
    p<span class="synSpecial">))</span>

<span class="synSpecial">(</span>time <span class="synSpecial">(</span>do-something-with-large-prime<span class="synSpecial">))</span>
<span class="synComment">;; =&gt; 122949829</span>
<span class="synComment">;(time (do-something-with-large-prime))</span>
<span class="synComment">; real   5.190</span>
<span class="synComment">; user   5.180</span>
<span class="synComment">; sys    0.020</span>
</pre><p>呼び出し時に*primes*の値を計算しているため、実行時間は5秒とかなり遅いです。<br />
この関数をload-time-constantを使って書きなおしてみましょう。</p>
<pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synComment">;; *primes* を初期化し、未計算の遅延リストに戻す</span>
<span class="synSpecial">(</span>reset-primes<span class="synSpecial">)</span>

<span class="synComment">;; define中に計算してるので、読み込むのに少し時間がかかる</span>
<span class="synSpecial">(</span><span class="synStatement">define</span> <span class="synSpecial">(</span>do-something-with-large-prime2<span class="synSpecial">)</span>
  <span class="synSpecial">(</span>let1 p <span class="synSpecial">(</span>load-time-constant user <span class="synSpecial">(</span><span class="synIdentifier">car</span> <span class="synSpecial">(</span>drop <span class="synConstant">*primes*</span> <span class="synConstant">7000000</span><span class="synSpecial">)))</span>
    p<span class="synSpecial">))</span>

<span class="synSpecial">(</span>reset-primes<span class="synSpecial">)</span> <span class="synComment">; 念の為もう一度リセット</span>
<span class="synSpecial">(</span>time <span class="synSpecial">(</span>do-something-with-large-prime2<span class="synSpecial">))</span>
<span class="synComment">;; =&gt; 122949829</span>
<span class="synComment">;(time (do-something-with-large-prime2))</span>
<span class="synComment">; real   0.000</span>
<span class="synComment">; user   0.000</span>
<span class="synComment">; sys    0.000</span>
</pre><p>(reset-primes)が呼ばれるたびに*primes*は未評価の遅延リストに戻るので、do-something-with-large-prime2の呼び出し時にpの値を評価しているのであれば、この関数の実行にも5秒程度かかるはずです。<br />
しかし、timeの結果を見ていただければわかりますが、実行時間はほとんどかかっておりません。</p><br />
<p>ロード時定数など無くても、実際はトッ<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%D7%A5%EC%A5%D9">プレベ</a>ルでdefineすれば事足りるのですが、わざわざ外に出すほどでもない定数もあるでしょうし、以前書いた<a href="/2016/10/29/151623.html">(current-load-path)&#x306E;&#x554F;&#x984C;</a>も、このマクロによってある程度は解決できるはずです。</p>


{% endraw %}
