---
layout: post
title: OCamlのFunctorという概念を知らずに自分で再発明していた話
tags:
- OCaml
- Gauche

---
{% raw %}
<p>最近わけあって<a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a>の勉強をしているのですが、<a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a>は多相的な関数を定義する方法として、Functorというものを持っています。</p>
<pre class="code lang-ocaml" data-lang="ocaml" data-unlink><span class="synComment">(* 要素の型と、その比較方法を定義するモジュール *)</span>
<span class="synStatement">module type </span><span class="synPreProc">Cmp</span> <span class="synStatement">=</span>
  <span class="synPreProc">sig</span>
    <span class="synStatement">type</span> elt
    <span class="synStatement">val</span> le : elt <span class="synStatement">-&gt;</span> elt <span class="synStatement">-&gt;</span> <span class="synType">bool</span> <span class="synComment">(* &lt;= *)</span>
  <span class="synPreProc">end</span>

<span class="synComment">(* Cmp の int による実装 *)</span>
<span class="synStatement">module</span><span class="synPreProc"> IntCmp</span> : <span class="synPreProc">Cmp</span> <span class="synStatement">with</span> <span class="synStatement">type</span> elt <span class="synStatement">=</span> <span class="synType">int</span> <span class="synStatement">=</span>
  <span class="synPreProc">struct</span>
    <span class="synStatement">type</span> elt <span class="synStatement">=</span> <span class="synType">int</span>
    <span class="synStatement">let</span> le <span class="synStatement">=</span> <span class="synStatement">(&lt;=)</span>
  <span class="synPreProc">end</span>

<span class="synStatement">module type </span><span class="synPreProc">Max</span> <span class="synStatement">=</span>
  <span class="synPreProc">sig</span>
    <span class="synStatement">type</span> elt
    <span class="synStatement">val</span> max : elt <span class="synStatement">-&gt;</span> elt <span class="synStatement">-&gt;</span> elt
    <span class="synStatement">val</span> min : elt <span class="synStatement">-&gt;</span> elt <span class="synStatement">-&gt;</span> elt
  <span class="synPreProc">end</span>

<span class="synComment">(* モジュール Cmp を受け取って、 max と min が定義されたモジュールを返す Functor *)</span>
<span class="synStatement">module</span><span class="synPreProc"> Max</span> (<span class="synPreProc">C</span> : <span class="synPreProc">Cmp</span>) : <span class="synPreProc">Max</span> <span class="synStatement">with</span> <span class="synStatement">type</span> elt <span class="synStatement">=</span> <span class="synPreProc">C</span>.elt <span class="synStatement">=</span>
  <span class="synPreProc">struct</span>
    <span class="synStatement">type</span> elt <span class="synStatement">=</span> <span class="synPreProc">C</span>.elt
    <span class="synStatement">let</span> max <span class="synStatement">(</span>x : elt<span class="synStatement">)</span> <span class="synStatement">(</span>y : elt<span class="synStatement">)</span> : elt <span class="synStatement">=</span>
      <span class="synStatement">if</span> <span class="synPreProc">C</span>.le x y
      <span class="synStatement">then</span> y
      <span class="synStatement">else</span> x
    <span class="synStatement">let</span> min <span class="synStatement">(</span>x : elt<span class="synStatement">)</span> <span class="synStatement">(</span>y : elt<span class="synStatement">)</span> : elt <span class="synStatement">=</span>
      <span class="synStatement">if</span> <span class="synPreProc">C</span>.le x y
      <span class="synStatement">then</span> x
      <span class="synStatement">else</span> y
  <span class="synPreProc">end</span>

<span class="synStatement">module</span><span class="synPreProc"> IntMax</span> : <span class="synPreProc">Max</span> <span class="synStatement">with</span> <span class="synStatement">type</span> elt <span class="synStatement">=</span> <span class="synType">int</span> <span class="synStatement">=</span> <span class="synConstant">Max</span><span class="synStatement">(</span><span class="synConstant">IntCmp</span><span class="synStatement">)</span>

<span class="synStatement">let</span> main : <span class="synType">unit</span> <span class="synStatement">=</span>
  <span class="synPreProc">Printf</span>.printf <span class="synConstant">&quot;max 2 3 = %d\n&quot;</span> <span class="synStatement">(</span><span class="synPreProc">IntMax</span>.max <span class="synConstant">2</span> <span class="synConstant">3</span><span class="synStatement">);</span>
  <span class="synPreProc">Printf</span>.printf <span class="synConstant">&quot;min 5 0 = %d\n&quot;</span> <span class="synStatement">(</span><span class="synPreProc">IntMax</span>.min <span class="synConstant">5</span> <span class="synConstant">0</span><span class="synStatement">)</span>
</pre><p>まだ<a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a>初心者なので拙い書き方になっているかもしれませんが、なんとなく雰囲気は伝わったと思います。<br />
要するに、<a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a>のFunctorとは「モジュールを引数にとってモジュールを返す関数」のようなものです。</p><br />
<p>しかし、このFunctorという概念について、自分は思い当たるものがありました。<br />
これは紛れもなく、自分が以前JAKLDに実装した、モジュールを利用した多相性を扱う手段でした。</p><br />
<p>話は数年前に遡ります。<br />
まだ自分が<a class="keyword" href="http://d.hatena.ne.jp/keyword/%B5%FE%C5%D4%C2%E7%B3%D8">京都大学</a>情報学科の1回生の頃の話でした。<br />
当時の京大の情報学科では、新入生が最初に学ぶ言語はJAKLDという言語でした。</p><p>JAKLDは<a class="keyword" href="http://d.hatena.ne.jp/keyword/Scheme">Scheme</a>の一種の方言であり、学生がどんな環境のPCでも<a class="keyword" href="http://d.hatena.ne.jp/keyword/SICP">SICP</a>の勉強ができるようにと、その昔京大の教授が<a class="keyword" href="http://d.hatena.ne.jp/keyword/Java">Java</a>で開発した処理系でした。<br />
確かに、JAKLDは<a class="keyword" href="http://d.hatena.ne.jp/keyword/SICP">SICP</a>に登場する関数や図形言語の(たぶん)全てを扱うことができます。<br />
しかし、この処理系はR5RSのサブセット+α程度のものでしかなく、実用的な<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC">プログラミング言語</a>とは程遠いものでした。</p><p>JAKLDにはモジュールシステムすら無く(モジュールが<a class="keyword" href="http://d.hatena.ne.jp/keyword/Scheme">Scheme</a>に導入されたのはR7RS以降なので、当たり前といえば当たり前ですが)、その環境で複雑なコードを書くのは苦痛以外の何者でもありませんでした。</p><p>そこで自分がまず開発したのは、Angularを参考にしたDIによるモジュール管理システムでした。<br />
実際のコードは紛失してしまったのですが、大体以下のような雰囲気でモジュールを定義することができるようなライブラリです。</p>
<pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synSpecial">(</span><span class="synStatement">define</span> my-module
  <span class="synSpecial">(</span>make-module <span class="synSpecial">'(</span>mod-a mod-b<span class="synSpecial">)</span> <span class="synComment">; インポートするモジュールのリスト</span>
   <span class="synSpecial">(</span><span class="synStatement">lambda</span> <span class="synSpecial">(</span>mod-a mod-b<span class="synSpecial">)</span> <span class="synComment">; モジュール自体は引数で受け取る</span>
     <span class="synSpecial">(</span><span class="synStatement">define</span> <span class="synSpecial">(</span>my-func foo<span class="synSpecial">)</span>
       <span class="synComment">;; モジュール内の関数 a は (mod 'a) で受け取る</span>
       <span class="synSpecial">((</span>mod-a <span class="synSpecial">'</span>some-func<span class="synSpecial">)</span> foo<span class="synSpecial">))</span>
     <span class="synSpecial">(</span><span class="synStatement">define</span> my-value <span class="synConstant">3</span><span class="synSpecial">)</span>

     <span class="synSpecial">(</span>export <span class="synSpecial">`((</span>my-func <span class="synSpecial">.</span> <span class="synSpecial">,</span>my-func<span class="synSpecial">)</span>
               <span class="synSpecial">(</span>my-value <span class="synSpecial">.</span> <span class="synSpecial">,</span>my-value<span class="synSpecial">)))</span>
     <span class="synSpecial">)))</span>
</pre><p>その後、<a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a>のような<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A2%A5%C9%A5%DB%A5%C3%A5%AF">アドホック</a>な多相性が欲しくなり、それを実現するために試行錯誤することとなりました。<br />
まず最初に試してみたのは通常の<a class="keyword" href="http://d.hatena.ne.jp/keyword/Lisp">Lisp</a>のように、多相性が欲しくなる部分を引数として受け取る方法です。</p>
<pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synSpecial">(</span><span class="synStatement">define</span> <span class="synSpecial">(</span>my-sort lst my-comperator<span class="synSpecial">)</span>
  <span class="synComment">;; comperator を使って要素を比較し、ソートする</span>
  ...<span class="synSpecial">)</span>
</pre><p>しかし、例えば<a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a>でいう</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>someFunc1 <span class="synStatement">::</span> (Eq a, Ord a, Show a) <span class="synStatement">=&gt;</span> a <span class="synStatement">-&gt;</span> b
someFunc2 <span class="synStatement">::</span> (Eq a, Ord a, Show a) <span class="synStatement">=&gt;</span> a <span class="synStatement">-&gt;</span> c
someFunc2 <span class="synStatement">=</span> somehow <span class="synStatement">$</span> someFunc1 a
</pre><p>のような関数を定義したい場合、<a class="keyword" href="http://d.hatena.ne.jp/keyword/Scheme">Scheme</a>では以下のような非常にわかりにくいコードになってしまいます。</p>
<pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synSpecial">(</span><span class="synStatement">define</span> <span class="synSpecial">(</span>some-func1 a a-eq? a-compare a-show<span class="synSpecial">)</span>
  ...<span class="synSpecial">)</span>
<span class="synSpecial">(</span><span class="synStatement">define</span> <span class="synSpecial">(</span>some-func2 a a-eq? a-compare a-show<span class="synSpecial">)</span>
  <span class="synSpecial">(</span>somehow <span class="synSpecial">(</span>some-func1 a a-eq? a-compare a-show<span class="synSpecial">)))</span>
</pre><p>多相性が必要な関数は、その型に関するすべての動作を引数で受け取らなければなりません。<br />
そのため、多相性が必要な型に関する制約が複雑になれば、それだけ引数の長さも増えていきます。<br />
また、多相性が必要なすべての関数に操作を引数として与えなければならないので、非常にコードが長くなります。</p><p>複数の関数を1つのデータ構造にしてまとめたりしてみましたが、根本的な解決にはなりません。</p><br />
<p>そこで思いついたのは、型aに関する複数の定義をまとめたモジュールを引数に受け取って、そのモジュール用に具体化されたモジュールを返すといった方法でした。<br />
例えば、以下の例では&lt;という関数を定義しているモジュールを引数にとって、その比較方法でソートを行うモジュールを返す関数のようなものを定義しています。</p>
<pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synSpecial">(</span><span class="synStatement">define</span> my-module2
  <span class="synSpecial">(</span>make-module
   <span class="synSpecial">'(</span>comparable<span class="synSpecial">)</span> <span class="synComment">;; 引数モジュール</span>
   <span class="synSpecial">'(</span>mod-a mod-b<span class="synSpecial">)</span> <span class="synComment">;; インポートリスト</span>
   <span class="synSpecial">(</span><span class="synStatement">lambda</span> <span class="synSpecial">(</span>comparable<span class="synSpecial">)</span>
     <span class="synSpecial">(</span><span class="synStatement">lambda</span> <span class="synSpecial">(</span>mod-a mod-b<span class="synSpecial">)</span>
       <span class="synComment">;; 引数で受け取ったモジュール内の &lt; を利用して</span>
       <span class="synComment">;; ソートを行う関数</span>
       <span class="synSpecial">(</span><span class="synStatement">define</span> <span class="synSpecial">(</span>my-sort lst<span class="synSpecial">)</span>
         <span class="synSpecial">(</span>sort-by lst <span class="synSpecial">(</span>comparable <span class="synSpecial">'</span>&lt;<span class="synSpecial">)))</span>

       <span class="synSpecial">(</span>export <span class="synSpecial">`((</span>my-sort <span class="synSpecial">.</span> <span class="synSpecial">,</span>my-sort<span class="synSpecial">)))</span>
     <span class="synSpecial">))))</span>
</pre><p>この「モジュール」を引数モジュール付きでインポートする構文は、確か次のようなものだったと思います。</p>
<pre class="code lang-scheme" data-lang="scheme" data-unlink><span class="synSpecial">(</span><span class="synStatement">define</span> main-module
  <span class="synSpecial">(</span>make-module
   <span class="synSpecial">'()</span>
   <span class="synSpecial">'((</span>my-module2 int-cmp<span class="synSpecial">))</span>
   <span class="synSpecial">(</span><span class="synStatement">lambda</span> <span class="synSpecial">()</span>
     <span class="synComment">;; my-mod2-int には、 my-module2 を int 用に特殊化したものが入る</span>
     <span class="synSpecial">(</span><span class="synStatement">lambda</span> <span class="synSpecial">(</span>my-mod2-int<span class="synSpecial">)</span>
       ...
       <span class="synSpecial">))))</span>
</pre><p>このようなモジュールシステムを作ることによって複雑な多相性を持つ関数を簡単に定義できるようになった僕は、これは大発明だと喜びながらその上で<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>やら何やらをせっせと構築していきましたとさ。めでたしめでたし。</p><br />
<br />
<p>今改めて考えてみると、この「モジュールを引数に取るモジュール」は<a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a>のFunctorに他なりません。<br />
当時の自分は他のどの言語にもない大発明だと思っていたので、少しショックですね……。</p>


{% endraw %}
