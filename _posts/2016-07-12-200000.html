---
layout: post
title: モナドで擬似マルチタスク
tags:
- Haskell

---
{% raw %}
<p>継続のことばかり考えていたらなんとなく思いついてしまったので載せておきます。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synSpecial">{-# LANGUAGE GADTs #-}</span>

<span class="synType">module</span> Concurrent <span class="synType">where</span>

<span class="synPreProc">import</span> Control.Monad
<span class="synPreProc">import</span> Control.Monad.IO.Class
<span class="synPreProc">import</span> Data.Either

<span class="synType">data</span> ConT m b <span class="synType">where</span>
  Done <span class="synStatement">::</span> m b <span class="synStatement">-&gt;</span> ConT m b
  Bind <span class="synStatement">::</span> ConT m a <span class="synStatement">-&gt;</span> (a <span class="synStatement">-&gt;</span> ConT m b) <span class="synStatement">-&gt;</span> ConT m b
  Fork <span class="synStatement">::</span> Int <span class="synStatement">-&gt;</span> ConT m Int

isDone <span class="synStatement">::</span> ConT m a <span class="synStatement">-&gt;</span> Bool
isDone (Done _) <span class="synStatement">=</span> True
isDone _ <span class="synStatement">=</span> False

<span class="synType">instance</span> Monad m <span class="synStatement">=&gt;</span> Monad (ConT m) <span class="synType">where</span>
  return <span class="synStatement">=</span> Done <span class="synStatement">.</span> return
  (<span class="synStatement">&gt;&gt;=</span>) <span class="synStatement">=</span> Bind

runConTs <span class="synStatement">::</span> Monad m <span class="synStatement">=&gt;</span> [ConT m a] <span class="synStatement">-&gt;</span> m [a]
runConTs cons
  <span class="synStatement">|</span> all isDone cons <span class="synStatement">=</span> mapM (<span class="synStatement">\</span>(Done x) <span class="synStatement">-&gt;</span> x) cons
  <span class="synStatement">|</span> otherwise <span class="synStatement">=</span> <span class="synStatement">do</span>
      cons' <span class="synStatement">&lt;-</span> foldM step [] cons
      runConTs cons'
  <span class="synType">where</span>
    step cons con <span class="synStatement">=</span> <span class="synStatement">do</span>
      cons' <span class="synStatement">&lt;-</span> stepConT con
      return <span class="synStatement">$</span> cons' <span class="synStatement">++</span> cons

runConT <span class="synStatement">::</span> Monad m <span class="synStatement">=&gt;</span> ConT m a <span class="synStatement">-&gt;</span> m [a]
runConT con <span class="synStatement">=</span> runConTs [con]

runConT_ <span class="synStatement">::</span> Monad m <span class="synStatement">=&gt;</span> ConT m a <span class="synStatement">-&gt;</span> m ()
runConT_ con <span class="synStatement">=</span> runConTs_ [con]

runConTs_ <span class="synStatement">::</span> Monad m <span class="synStatement">=&gt;</span> [ConT m a] <span class="synStatement">-&gt;</span> m ()
runConTs_ cons <span class="synStatement">=</span> runConTs cons <span class="synStatement">&gt;&gt;</span> return ()

stepConT <span class="synStatement">::</span> Monad m <span class="synStatement">=&gt;</span> ConT m a <span class="synStatement">-&gt;</span> m [ConT m a]
stepConT (Done res) <span class="synStatement">=</span> <span class="synStatement">do</span>
  r <span class="synStatement">&lt;-</span> res
  return [Done (return r)]
stepConT (Bind (Done res) cont) <span class="synStatement">=</span> <span class="synStatement">do</span>
  r <span class="synStatement">&lt;-</span> res
  return [cont r]
stepConT (Bind ma cont) <span class="synStatement">=</span> <span class="synStatement">do</span>
  mas <span class="synStatement">&lt;-</span> stepConT ma
  return <span class="synStatement">$</span> map (<span class="synStatement">\</span>ma' <span class="synStatement">-&gt;</span> Bind ma' cont) mas
stepConT (Fork num) <span class="synStatement">=</span> return [Done (return i) <span class="synStatement">|</span> i <span class="synStatement">&lt;-</span> [<span class="synConstant">0</span><span class="synStatement">..</span>num<span class="synStatement">-</span><span class="synConstant">1</span>]]

<span class="synType">instance</span> MonadIO m <span class="synStatement">=&gt;</span> MonadIO (ConT m) <span class="synType">where</span>
  liftIO <span class="synStatement">=</span> Done <span class="synStatement">.</span> liftIO

<span class="synComment">-- (擬似)プロセスをn個に分ける</span>
<span class="synComment">-- 戻り地は自分が何番目のプロセスか</span>
fork <span class="synStatement">::</span> Int <span class="synStatement">-&gt;</span> ConT m Int
fork <span class="synStatement">=</span> Fork
</pre><p>a >>= bがそのままBind a bというデータ構造になっているため、doブロック内の命令1行ごとに処理を停止することができるようになっています。<br />
Forkは本来は特に必要ないのですが、なんとなくfork()的なことがしたかったので入れてみました。</p><p>以下実行例。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>count <span class="synStatement">::</span> MonadIO m <span class="synStatement">=&gt;</span> String <span class="synStatement">-&gt;</span> Int <span class="synStatement">-&gt;</span> ConT m ()
count name times <span class="synStatement">=</span> forM_ [<span class="synConstant">0</span><span class="synStatement">..</span>times<span class="synStatement">-</span><span class="synConstant">1</span>] <span class="synStatement">$</span> <span class="synStatement">\</span>i <span class="synStatement">-&gt;</span> <span class="synStatement">do</span>
  liftIO <span class="synStatement">$</span> putStrLn <span class="synStatement">$</span> name <span class="synStatement">++</span> <span class="synConstant">&quot;: &quot;</span> <span class="synStatement">++</span> show i

forkExample <span class="synStatement">::</span> MonadIO m <span class="synStatement">=&gt;</span> ConT m ()
forkExample <span class="synStatement">=</span> <span class="synStatement">do</span>
  pid <span class="synStatement">&lt;-</span> fork <span class="synConstant">5</span>
  <span class="synStatement">case</span> pid <span class="synStatement">of</span>
    <span class="synConstant">0</span> <span class="synStatement">-&gt;</span> <span class="synStatement">do</span>
      liftIO <span class="synStatement">$</span> putStrLn <span class="synConstant">&quot;I am zero!&quot;</span>
      count <span class="synConstant">&quot;zero&quot;</span> <span class="synConstant">3</span>
    _ <span class="synStatement">-&gt;</span> <span class="synStatement">do</span>
      liftIO <span class="synStatement">$</span> putStrLn <span class="synStatement">$</span> <span class="synConstant">&quot;I am process &quot;</span> <span class="synStatement">++</span> show pid <span class="synStatement">++</span> <span class="synConstant">&quot;!&quot;</span>
      count (<span class="synConstant">&quot;process&quot;</span> <span class="synStatement">++</span> show pid) <span class="synConstant">3</span>
</pre><p>実行結果:</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synStatement">&gt;&gt;&gt;</span> runConT forkExample 
I am process <span class="synConstant">4</span><span class="synStatement">!</span>
I am process <span class="synConstant">3</span><span class="synStatement">!</span>
I am process <span class="synConstant">2</span><span class="synStatement">!</span>
I am process <span class="synConstant">1</span><span class="synStatement">!</span>
I am zero<span class="synStatement">!</span>
zero<span class="synStatement">:</span> <span class="synConstant">0</span>
process1<span class="synStatement">:</span> <span class="synConstant">0</span>
process2<span class="synStatement">:</span> <span class="synConstant">0</span>
process3<span class="synStatement">:</span> <span class="synConstant">0</span>
process4<span class="synStatement">:</span> <span class="synConstant">0</span>
process4<span class="synStatement">:</span> <span class="synConstant">1</span>
process3<span class="synStatement">:</span> <span class="synConstant">1</span>
process2<span class="synStatement">:</span> <span class="synConstant">1</span>
process1<span class="synStatement">:</span> <span class="synConstant">1</span>
zero<span class="synStatement">:</span> <span class="synConstant">1</span>
zero<span class="synStatement">:</span> <span class="synConstant">2</span>
process1<span class="synStatement">:</span> <span class="synConstant">2</span>
process2<span class="synStatement">:</span> <span class="synConstant">2</span>
process3<span class="synStatement">:</span> <span class="synConstant">2</span>
process4<span class="synStatement">:</span> <span class="synConstant">2</span>
[(),(),(),(),()]
</pre><p>まず最初にfork 5でzeroとprocess1〜4の5つに分かれ、それぞれが平行して0〜2までのカウントを行っています。</p>


{% endraw %}
