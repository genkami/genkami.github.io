---
layout: post
title: Elmの型関連が弱すぎてつらい
tags:
- Elm

---
{% raw %}
<p><iframe src="http://inkar-us-i.hatenablog.com/embed/2017/02/06/211658" title="Elm始めてみました。 - きくらげ観察日記" class="embed-card embed-blogcard" scrolling="no" frameborder="0" style="display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;"></iframe><cite class="hatena-citation"><a href="/2017/02/06/211658.html">inkar-us-i.hatenablog.com</a></cite></p><p>ここでやたらElm推してるみたいな書き方をしてしまいましたが、僕自身はそんなにElm好きではありません。</p>

<div class="section">
    <h3>型クラスがない</h3>
    <p>Elmには型クラスが無いため、まともに多相的な関数を書くことはできません。<br />
例えば、Elmには至る所でモナディックな処理が出てきます。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synComment">-- Maybeモナド</span>
Just <span class="synConstant">3</span>
  <span class="synStatement">|&gt;</span> Maybe.andThen (<span class="synStatement">\</span>x <span class="synStatement">-&gt;</span> <span class="synStatement">if</span> x <span class="synStatement">==</span> <span class="synConstant">3</span> <span class="synStatement">then</span> Nothing <span class="synStatement">else</span> Just (x <span class="synStatement">+</span> <span class="synConstant">1</span>))
<span class="synComment">-- Cmdモナド</span>
Http.get string <span class="synConstant">&quot;http://hoge.com&quot;</span>
  <span class="synStatement">|&gt;</span> Task.andThen (<span class="synStatement">\</span>url <span class="synStatement">-&gt;</span> Http.get (list string) url)
<span class="synComment">-- Random.Generatorモナド</span>
Random.int <span class="synConstant">0</span> <span class="synConstant">10</span>
  <span class="synStatement">|&gt;</span> Random.andThen (<span class="synStatement">\</span>n <span class="synStatement">-&gt;</span> Random.int n <span class="synConstant">100</span>)
</pre><p>この andThen が<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>の >>= に相当するのですが、これらの3つのandThenは全て別々に実装されたものとなります。<br />
この他にも、<a class="keyword" href="http://d.hatena.ne.jp/keyword/haskell">haskell</a>のliftM, liftM2 に対応するmap, map2もそれぞれのライブラリで定義されているのですが、これらは全て「別々に」定義されています。<br />
実際は、「a -> m b」なる関数returnと、このandThenの2つの関数さえ用意すれば、残りのmap2等の関数は全てそこから自動的に定義できるはずです。</p><p>また、例えば同じ生成器で乱数をn回生成するrepeatGenという関数を作ろうと思ったとします。<br />
この関数は以下のように書くことができます。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>repeatGen <span class="synStatement">:</span> Int <span class="synStatement">-&gt;</span> Generator a <span class="synStatement">-&gt;</span> Generator (List a)
repeatGen n gen <span class="synStatement">=</span>
    <span class="synStatement">let</span> return x <span class="synStatement">=</span> Random.map (<span class="synStatement">\</span>_ <span class="synStatement">-&gt;</span> x) Random.bool <span class="synComment">-- return が無いので代用。厳密にはモナド則を満たさなくなるけど今は無視</span>
    <span class="synStatement">in</span> <span class="synStatement">if</span> n <span class="synStatement">&lt;=</span> <span class="synConstant">0</span> <span class="synStatement">then</span> return []
       <span class="synStatement">else</span> Random.map2 (<span class="synStatement">::</span>) gen (repeatGen (n <span class="synStatement">-</span> <span class="synConstant">1</span>) gen)
</pre><p>この関数はだいたい思った通りに動作します。<br />
この後、同じタスクをn回実行するrepeatTaskが欲しくなったとします。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>repeatTask <span class="synStatement">:</span> Int <span class="synStatement">-&gt;</span> Generator a <span class="synStatement">-&gt;</span> Generator (List a)
repeatTask n task <span class="synStatement">=</span>
    <span class="synStatement">let</span> return x <span class="synStatement">=</span> Task.succeed x
    <span class="synStatement">in</span> <span class="synStatement">if</span> n <span class="synStatement">&lt;=</span> <span class="synConstant">0</span> <span class="synStatement">then</span> return []
    <span class="synStatement">else</span> Task.map2 (<span class="synStatement">::</span>) task (repeatTask (n <span class="synStatement">-</span> <span class="synConstant">1</span>) task)
</pre><p>この定義を見てください。ほとんどrepaetGenと同じです。<br />
<a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a>の場合は、一般の<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>について以下のようにrepeatMを定義することができます。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>repeatM <span class="synStatement">::</span> Monad m <span class="synStatement">=&gt;</span> Int <span class="synStatement">-&gt;</span> m a <span class="synStatement">-&gt;</span> m [a]
repeatM n action <span class="synStatement">=</span>
    <span class="synStatement">if</span> n <span class="synStatement">&lt;=</span> <span class="synConstant">0</span> <span class="synStatement">then</span> return []
    <span class="synStatement">else</span> liftM2 (<span class="synStatement">:</span>) action (repeatM (n <span class="synStatement">-</span> <span class="synConstant">1</span>) action)
</pre><p>しかし、Elmは言語機能が貧弱なため、このような関数をElmで書くことはできません。<br />
不便ではありますが、言語仕様なので我慢するしかありません。</p>

</div>
<div class="section">
    <h3>高階多相やRankN多相が使えない</h3>
    <p><a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a>の場合、型クラスという言語機能がなかったとしても、以下のように<a class="keyword" href="http://d.hatena.ne.jp/keyword/Monad">Monad</a>を明示的に渡してしまうことによって、少し不便ではありますが似たような操作を行うことができます。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synType">data</span> Monad m <span class="synStatement">=</span> Monad {
    return <span class="synStatement">::</span> a <span class="synStatement">-&gt;</span> m a
    <span class="synComment">-- Elm 風に</span>
  , andThen <span class="synStatement">::</span> (a <span class="synStatement">-&gt;</span> m b) <span class="synStatement">-&gt;</span> m a <span class="synStatement">-&gt;</span> m b
  }

<span class="synComment">-- Elm 風に</span>
(<span class="synStatement">|&gt;</span>) <span class="synStatement">::</span> a <span class="synStatement">-&gt;</span> (a <span class="synStatement">-&gt;</span> b) <span class="synStatement">-&gt;</span> b
a <span class="synStatement">|&gt;</span> f <span class="synStatement">=</span> f a
<span class="synPreProc">infixl</span> <span class="synConstant">1</span> <span class="synStatement">|&gt;</span>

map2 <span class="synStatement">::</span> Monad m <span class="synStatement">-&gt;</span> (a <span class="synStatement">-&gt;</span> b <span class="synStatement">-&gt;</span> c) <span class="synStatement">-&gt;</span> m a <span class="synStatement">-&gt;</span> m b <span class="synStatement">-&gt;</span> m c
map2 monad f ma mb <span class="synStatement">=</span>
  ma <span class="synStatement">|&gt;</span> andThen monad (<span class="synStatement">\</span>a <span class="synStatement">-&gt;</span> mb <span class="synStatement">|&gt;</span> andThen monad (<span class="synStatement">\</span>b <span class="synStatement">-&gt;</span> return monad (f a b)))

repeatM' <span class="synStatement">::</span> Monad m <span class="synStatement">-&gt;</span> Int <span class="synStatement">-&gt;</span> m a <span class="synStatement">-&gt;</span> m [a]
repeatM' monad n action <span class="synStatement">=</span>
  <span class="synStatement">if</span> n <span class="synStatement">&lt;=</span> <span class="synConstant">0</span> <span class="synStatement">then</span> return monad []
  <span class="synStatement">else</span> map2 monad (<span class="synStatement">:</span>) action (repeatM' monad (n <span class="synStatement">-</span> <span class="synConstant">1</span>) action)
</pre><p>しかし、これをElmでやろうとした場合、forallに相当する機能が無いため、このような関数を書くことはできません。<br />
また、そもそも高階多相が無いため、</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink>return <span class="synStatement">:</span> a <span class="synStatement">-&gt;</span> f a
</pre><p>のような関数を定義することすらできません。</p>

</div>
<div class="section">
    <h3>Functorもない</h3>
    <p>「いや、<a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a>だって高階多相やRankN多相は無いし、それだけでじゃ<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%B9%A4%EB">ディスる</a>理由にならないだろ」と言う方もいるかもしれません。それはたしかにその通りです。しかし、<a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a>にはその代わりにFunctorという素晴らしい機能があります。</p>
<pre class="code lang-ocaml" data-lang="ocaml" data-unlink><span class="synStatement">module type </span><span class="synPreProc">MONAD</span> <span class="synStatement">=</span>
  <span class="synPreProc">sig</span>
    <span class="synStatement">type</span> 'a t
    <span class="synStatement">val</span> return : 'a <span class="synStatement">-&gt;</span> 'a t
    <span class="synStatement">val</span> and_then : <span class="synStatement">(</span>'a <span class="synStatement">-&gt;</span> 'b t<span class="synStatement">)</span> <span class="synStatement">-&gt;</span> 'a t <span class="synStatement">-&gt;</span> 'b t
  <span class="synPreProc">end</span>

<span class="synStatement">module</span><span class="synPreProc"> Make</span> (<span class="synPreProc">M</span> : <span class="synPreProc">MONAD</span>) <span class="synStatement">=</span>
  <span class="synPreProc">struct</span>
    <span class="synStatement">let</span> map2 <span class="synStatement">(</span>f : 'a <span class="synStatement">-&gt;</span> 'b <span class="synStatement">-&gt;</span> 'c<span class="synStatement">)</span> <span class="synStatement">(</span>ma : 'a <span class="synPreProc">M</span>.t<span class="synStatement">)</span> <span class="synStatement">(</span>mb : 'b <span class="synPreProc">M</span>.t<span class="synStatement">)</span> : 'c <span class="synPreProc">M</span>.t <span class="synStatement">=</span>
      ma <span class="synStatement">|&gt;</span> <span class="synPreProc">M</span>.and_then <span class="synStatement">(fun</span> a <span class="synStatement">-&gt;</span> mb <span class="synStatement">|&gt;</span> <span class="synPreProc">M</span>.and_then <span class="synStatement">(fun</span> b <span class="synStatement">-&gt;</span> <span class="synPreProc">M</span>.return <span class="synStatement">(</span>f a b<span class="synStatement">)))</span>
    <span class="synStatement">let</span> <span class="synStatement">rec</span> repeat <span class="synStatement">(</span>n : <span class="synType">int</span><span class="synStatement">)</span> <span class="synStatement">(</span>action : 'a <span class="synPreProc">M</span>.t<span class="synStatement">)</span> : 'a <span class="synType">list</span> <span class="synPreProc">M</span>.t <span class="synStatement">=</span>
      <span class="synStatement">if</span> n <span class="synStatement">&lt;=</span> <span class="synConstant">0</span> <span class="synStatement">then</span> <span class="synPreProc">M</span>.return <span class="synConstant">[]</span>
      <span class="synStatement">else</span> map2 <span class="synStatement">(fun</span> x y <span class="synStatement">-&gt;</span> x <span class="synStatement">::</span> y<span class="synStatement">)</span> action <span class="synStatement">(</span>repeat <span class="synStatement">(</span>n - <span class="synConstant">1</span><span class="synStatement">)</span> action<span class="synStatement">)</span>
  <span class="synPreProc">end</span>
</pre><p>Functorを使うことによって、使用方法は少し異なりますが<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>を書くことができます。<br />
重要なのは、一度このFunctor Makeを書いてしまえば、Random.GeneratorだろうがTaskだろうが同じように使うことができることです。</p><p>しかし、ElmにはFunctorもありません。したがって、この方法でも多相的な関数を書くことはできません。</p>

</div>
<div class="section">
    <h3>その代わりにある謎機能</h3>
    <p>しかし、組み込み関数の(+)はIntだろうがFloatだろうが使えますし、(++)はListだろうがStringだろうが連結できてしまいます。これらは一体どのように定義されているのでしょうか？</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synStatement">&gt;</span> <span class="synConstant">3.0</span> <span class="synStatement">+</span> <span class="synConstant">2.0</span>
<span class="synConstant">5</span> <span class="synStatement">:</span> Float
<span class="synStatement">&gt;</span> [<span class="synConstant">1</span>, <span class="synConstant">2</span>, <span class="synConstant">3</span>] <span class="synStatement">++</span> [<span class="synConstant">4</span>, <span class="synConstant">5</span>, <span class="synConstant">7</span>]
[<span class="synConstant">1</span>,<span class="synConstant">2</span>,<span class="synConstant">3</span>,<span class="synConstant">4</span>,<span class="synConstant">5</span>,<span class="synConstant">7</span>] <span class="synStatement">:</span> List number
<span class="synStatement">&gt;</span> <span class="synConstant">&quot;hoge&quot;</span> <span class="synStatement">++</span> <span class="synConstant">&quot;fuga&quot;</span>
<span class="synConstant">&quot;hogefuga&quot;</span> <span class="synStatement">:</span> String
<span class="synStatement">&gt;</span> (<span class="synStatement">+</span>)
<span class="synStatement">&lt;</span>function<span class="synStatement">&gt;</span> <span class="synStatement">:</span> number <span class="synStatement">-&gt;</span> number <span class="synStatement">-&gt;</span> number
<span class="synStatement">&gt;</span> (<span class="synStatement">++</span>)
<span class="synStatement">&lt;</span>function<span class="synStatement">&gt;</span> <span class="synStatement">:</span> appendable <span class="synStatement">-&gt;</span> appendable <span class="synStatement">-&gt;</span> appendable
</pre><p>それぞれnumber, appendableという型変数名になっています。<br />
実はこれは処理系による例外的な機能で、変数名の頭が「number」「appendable」である型変数は特別扱いされ、numberなら数値、appendableならリストや文字列などの連結できる任意の型を受け取ることができるようになっています。この他に、比較可能な型を表すcomparableなどもあります。</p><p>しかし、これらはあくまで「例外」的な機能です。新しく作った型をnumberやappendableのメンバーとして登録することもできませんし、これらの「型クラスのようなもの」を新たに作ることもできません。</p><br />
<p>このようにElmは型に関する機能が十分ではないため、どんな場合にも使用できるような高度に抽象化された関数を書くことはできません。<br />
出来合いのライブラリを使って何かするだけなら便利かもしれませんが、ライブラリを作る側に回った時には非常に不便な言語です。</p>

</div>

{% endraw %}
