---
layout: post
title: ScalaFXで作ったウィンドウのonDragDroppedが呼ばれない
tags:
- Scala

---
{% raw %}

<div class="section">
    <h3>問題となったコード</h3>
    <pre class="code lang-scala" data-lang="scala" data-unlink><span class="synPreProc">import</span> scalafx.Includes._
<span class="synPreProc">import</span> scalafx.application.JFXApp
<span class="synPreProc">import</span> scalafx.application.JFXApp.PrimaryStage
<span class="synPreProc">import</span> scalafx.geometry.Insets
<span class="synPreProc">import</span> scalafx.scene.Scene
<span class="synPreProc">import</span> scalafx.scene.input.DragEvent
<span class="synPreProc">import</span> scalafx.scene.control.Label
<span class="synPreProc">import</span> scalafx.scene.layout.BorderPane

<span class="synType">object</span> DropTarget <span class="synType">extends</span> JFXApp {
  stage = <span class="synStatement">new</span> PrimaryStage {
    title = <span class="synConstant">&quot;DropTarget&quot;</span>
    scene = <span class="synStatement">new</span> Scene {
      root = <span class="synStatement">new</span> BorderPane {
        padding = Insets(<span class="synConstant">25</span>)
        <span class="synType">val</span> message = <span class="synStatement">new</span> Label(<span class="synConstant">&quot;Drop files here!&quot;</span>)
        center = message
        onDragEntered = (ev: DragEvent) =&gt; {
          println(<span class="synConstant">&quot;entered&quot;</span>)
          ev.consume()
        }
        onDragExited = (ev: DragEvent) =&gt; {
          println(<span class="synConstant">&quot;exited&quot;</span>)
          ev.consume()
        }
        onDragOver = (ev: DragEvent) =&gt; {
          println(<span class="synConstant">&quot;over&quot;</span>)
          ev.consume()
        }
        onDragDropped = (ev: DragEvent) =&gt; {
          println(<span class="synConstant">&quot;dropped&quot;</span>)
          message.text = <span class="synConstant">&quot;Dropped!&quot;</span>
          ev.consume()
        }
      }
    }
  }
}
</pre><p><iframe src="http://inkar-us-i.hatenablog.com/embed/2016/02/23/072500" title="ScalaFXを触ってみる - きくらげ観察日記" class="embed-card embed-blogcard" scrolling="no" frameborder="0" style="display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;"></iframe><cite class="hatena-citation"><a href="/2016/02/23/072500.html">inkar-us-i.hatenablog.com</a></cite><br />
こちらで作った<a class="keyword" href="http://d.hatena.ne.jp/keyword/Hello%20World">Hello World</a>に、ドロップ関連のハンドラを設定しただけのシンプルなものです。<br />
onHogehogeに設定する値はEventHandlerなので、<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E9%A5%E0%A5%C0%BC%B0">ラムダ式</a>の(Event => Unit)型から暗黙的に変換してやる必要があります。そのためにscalafx.Includes._のimportが必要になっています。このあたりは<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E9%A5%E0%A5%C0%BC%B0">ラムダ式</a>を任意の関数型インターフェースの<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9">インスタンス</a>として認識してくれる<a class="keyword" href="http://d.hatena.ne.jp/keyword/Java">Java</a>のほうが賢い作りになっているとも言えますが、そもそも<a class="keyword" href="http://d.hatena.ne.jp/keyword/Java">Java</a>のライブラリのラッパでなければEventHandlerクラスなど定義せずに素直に(Event => Unit)を受け取るような仕様になっていたはずなので、何とも言えない所。</p><p>ドロップ関連の<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A4%A5%D9%A5%F3%A5%C8%A5%CF%A5%F3%A5%C9%A5%E9">イベントハンドラ</a>は以下の4つで、それぞれ次の状態で呼ばれます。</p>

<table>
    <tr>
    <th>名前</th>
    <td>説明</td>
    </tr>
    <tr>
    <td>onDragEntered</td>
    <td>ドラッグしてきた対象がこのノードの上に入った時</td>
    </tr>
    <tr>
    <td>onDragOver</td>
    <td>ドラッグしてきた対象がこのノードの上にいる間、繰り返し呼ばれる</td>
    </tr>
    <tr>
    <td>onDragExited</td>
    <td>ドラッグしてきた対象がこのノードの上から消えた時</td>
    </tr>
    <tr>
    <td>onDragDropped</td>
    <td>ドラッグしてきた対象がこのノードの上でドロップされた時</td>
    </tr>
</table><p>ということなので、先ほどの<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9">ソースコード</a>を実行して出てきたウィンドウに適当なものをドラッグしてくると、以下のように出力されるはずです。</p>

<pre>entered
over
over
over
...
over
(ここでマウスをはなす)
dropped
exited
</pre><p>実際に実行してみた結果はこちら。以下のようなウィンドウが表示されます。</p><p><span itemscope itemtype="http://schema.org/Photograph"><img src="http://cdn-ak.f.st-hatena.com/images/fotolife/c/cloudear8/20160223/20160223230123.png" alt="f:id:cloudear8:20160223230123p:plain" title="f:id:cloudear8:20160223230123p:plain" class="hatena-fotolife" itemprop="image"></span></p><p>これに外からファイルか何かをドラッグしてくると…</p>

<pre>entered
over
over
...
over
(ここでマウスをはなす)
exited
</pre><p>onDragDroppedが呼ばれていません。</p>

</div>
<div class="section">
    <h3>解決策</h3>
    <p><a href="https://docs.oracle.com/javafx/2/api/javafx/scene/input/DragEvent.html">DragEvent (JavaFX 2.2)</a></p><p>このドキュメントを参考にすると、実際に要素がドロップされる前の段階で、acceptTransferModesを設定しなければならいようです。<br />
使用できるTransferModeは以下の通り</p><p><a href="http://docs.oracle.com/javase/8/javafx/api/javafx/scene/input/TransferMode.html">TransferMode (JavaFX 8)</a></p><p>これに従って、コードを次のように書き換えます。</p>
<pre class="code lang-scala" data-lang="scala" data-unlink>onDragOver = (ev: DragEvent) =&gt; {
  ev.acceptTransferModes(TransferMode.ANY: _*)
  println(<span class="synConstant">&quot;over&quot;</span>)
  ev.consume()
}
</pre><p>TransferModeはscalafx.scene.input以下で定義されているので、そちらのimportも忘れずに。</p><p>これを実行すると期待通りの出力が得られる上、ドロップ後にはウィンドウの表示もちゃんと変更されます。<br />
<span itemscope itemtype="http://schema.org/Photograph"><img src="http://cdn-ak.f.st-hatena.com/images/fotolife/c/cloudear8/20160223/20160223230914.png" alt="f:id:cloudear8:20160223230914p:plain" title="f:id:cloudear8:20160223230914p:plain" class="hatena-fotolife" itemprop="image"></span><br />
やっぱり困ったら<a class="keyword" href="http://d.hatena.ne.jp/keyword/JavaFX">JavaFX</a>のドキュメントに当たるのが正しいようです。</p><br />
<p><div class="hatena-asin-detail"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4844330845/cloudear-22/"><img src="http://ecx.images-amazon.com/images/I/415CsfYp64L._SL160_.jpg" class="hatena-asin-detail-image" alt="Scalaスケーラブルプログラミング第2版" title="Scalaスケーラブルプログラミング第2版"></a><div class="hatena-asin-detail-info"><p class="hatena-asin-detail-title"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4844330845/cloudear-22/">Scalaスケーラブルプログラミング第2版</a></p><ul><li><span class="hatena-asin-detail-label">作者:</span> Martin Odersky,Lex Spoon,Bill Venners,羽生田栄一,水島宏太,長尾高弘</li><li><span class="hatena-asin-detail-label">出版社/メーカー:</span> <a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%D7%A5%EC%A5%B9%A5%B8%A5%E3%A5%D1%A5%F3">インプレスジャパン</a></li><li><span class="hatena-asin-detail-label">発売日:</span> 2011/09/27</li><li><span class="hatena-asin-detail-label">メディア:</span> 単行本（ソフトカバー）</li><li><span class="hatena-asin-detail-label">購入</span>: 12人 <span class="hatena-asin-detail-label">クリック</span>: 235回</li><li><a href="http://d.hatena.ne.jp/asin/4844330845/cloudear-22" target="_blank">この商品を含むブログ (46件) を見る</a></li></ul></div><div class="hatena-asin-detail-foot"></div></div><div class="hatena-asin-detail"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4877833765/cloudear-22/"><img src="http://ecx.images-amazon.com/images/I/51sqlqiwgpL._SL160_.jpg" class="hatena-asin-detail-image" alt="JavaFX & Java8プログラミング―Javaによる新しいGUIプログラミング入門" title="JavaFX & Java8プログラミング―Javaによる新しいGUIプログラミング入門"></a><div class="hatena-asin-detail-info"><p class="hatena-asin-detail-title"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4877833765/cloudear-22/">JavaFX & Java8プログラミング―Javaによる新しいGUIプログラミング入門</a></p><ul><li><span class="hatena-asin-detail-label">作者:</span> 日向俊二</li><li><span class="hatena-asin-detail-label">出版社/メーカー:</span> カットシステム</li><li><span class="hatena-asin-detail-label">発売日:</span> 2015/08</li><li><span class="hatena-asin-detail-label">メディア:</span> 単行本</li><li><a href="http://d.hatena.ne.jp/asin/4877833765/cloudear-22" target="_blank">この商品を含むブログを見る</a></li></ul></div><div class="hatena-asin-detail-foot"></div></div></p>

</div>

{% endraw %}
