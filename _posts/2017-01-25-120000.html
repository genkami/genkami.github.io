---
layout: post
title: 型クラスのインスタンスが複数ある場合の話(Haskell編)
tags:
- Haskell

---
{% raw %}
<p><iframe src="http://inkar-us-i.hatenablog.com/embed/2017/01/24/152922" title="implicit parameterによる型クラスの罠 - きくらげ観察日記" class="embed-card embed-blogcard" scrolling="no" frameborder="0" style="display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;"></iframe><cite class="hatena-citation"><a href="/2017/01/24/152922.html">inkar-us-i.hatenablog.com</a></cite></p><p>こちらで出した例は<a class="keyword" href="http://d.hatena.ne.jp/keyword/Scala">Scala</a>でしたが、<a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a>でも同様の問題は起こりえます。</p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synComment">-- TreeSet.hs</span>
<span class="synType">module</span> TreeSet (
    Cmp(<span class="synStatement">..</span>)
  , TreeSet()
  , empty
  , insert
  , fromList
  , elem
  ) <span class="synType">where</span>

<span class="synPreProc">import</span> Prelude <span class="synPreProc">hiding</span> (elem)

<span class="synType">class</span> Cmp a <span class="synType">where</span>
  eq <span class="synStatement">::</span> a <span class="synStatement">-&gt;</span> a <span class="synStatement">-&gt;</span> Bool
  lt <span class="synStatement">::</span> a <span class="synStatement">-&gt;</span> a <span class="synStatement">-&gt;</span> Bool

<span class="synType">data</span> TreeSet a
  <span class="synStatement">=</span> Branch a (TreeSet a) (TreeSet a)
  <span class="synStatement">|</span> Leaf

empty <span class="synStatement">::</span> TreeSet a
empty <span class="synStatement">=</span> Leaf

insert <span class="synStatement">::</span> Cmp a <span class="synStatement">=&gt;</span> a <span class="synStatement">-&gt;</span> TreeSet a <span class="synStatement">-&gt;</span> TreeSet a
insert x Leaf <span class="synStatement">=</span> Branch x Leaf Leaf
insert x t<span class="synStatement">@</span>(Branch y left right)
  <span class="synStatement">|</span> eq x y    <span class="synStatement">=</span> t
  <span class="synStatement">|</span> lt x y    <span class="synStatement">=</span> Branch y (insert x left) right
  <span class="synStatement">|</span> otherwise <span class="synStatement">=</span> Branch y left (insert x right)

fromList <span class="synStatement">::</span> Cmp a <span class="synStatement">=&gt;</span> [a] <span class="synStatement">-&gt;</span> TreeSet a
fromList xs <span class="synStatement">=</span> foldl (flip insert) Leaf xs

elem <span class="synStatement">::</span> Cmp a <span class="synStatement">=&gt;</span> a <span class="synStatement">-&gt;</span> TreeSet a <span class="synStatement">-&gt;</span> Bool
elem _ Leaf <span class="synStatement">=</span> False
elem x (Branch y left right)
  <span class="synStatement">|</span> eq x y    <span class="synStatement">=</span> True
  <span class="synStatement">|</span> lt x y    <span class="synStatement">=</span> elem x left
  <span class="synStatement">|</span> otherwise <span class="synStatement">=</span> elem x right
</pre><pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synComment">-- ModA.hs</span>
<span class="synType">module</span> ModA (someSet) <span class="synType">where</span>

<span class="synPreProc">import</span> <span class="synPreProc">qualified</span> TreeSet <span class="synPreProc">as</span> TS

<span class="synComment">-- 通常の順序</span>
<span class="synType">instance</span> TS.Cmp Int <span class="synType">where</span>
  eq <span class="synStatement">=</span> (<span class="synStatement">==</span>)
  lt <span class="synStatement">=</span> (<span class="synStatement">&lt;</span>)

someSet <span class="synStatement">::</span> TS.TreeSet Int
someSet <span class="synStatement">=</span> TS.fromList [<span class="synConstant">5</span>, <span class="synConstant">3</span>, <span class="synConstant">7</span>, <span class="synConstant">1</span>, <span class="synConstant">6</span>]
</pre><pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synComment">-- ModB.hs</span>
<span class="synType">module</span> ModB (is7InSet) <span class="synType">where</span>

<span class="synPreProc">import</span> <span class="synPreProc">qualified</span> TreeSet <span class="synPreProc">as</span> TS

<span class="synComment">-- 逆順</span>
<span class="synType">instance</span> TS.Cmp Int <span class="synType">where</span>
  eq <span class="synStatement">=</span> (<span class="synStatement">==</span>)
  lt <span class="synStatement">=</span> (<span class="synStatement">&gt;</span>)

is7InSet <span class="synStatement">::</span> TS.TreeSet Int <span class="synStatement">-&gt;</span> Bool
is7InSet set <span class="synStatement">=</span> TS.elem <span class="synConstant">7</span> set
</pre><pre class="code lang-haskell" data-lang="haskell" data-unlink><span class="synComment">-- ModC.hs</span>
<span class="synType">module</span> ModC <span class="synType">where</span>

<span class="synPreProc">import</span> <span class="synPreProc">qualified</span> ModA
<span class="synPreProc">import</span> <span class="synPreProc">qualified</span> ModB
<span class="synPreProc">import</span> <span class="synPreProc">qualified</span> TreeSet <span class="synPreProc">as</span> TS

main <span class="synStatement">=</span> <span class="synStatement">do</span>
  <span class="synStatement">if</span> ModB.is7InSet ModA.someSet
    <span class="synStatement">then</span> putStrLn <span class="synConstant">&quot;7 is in someSet&quot;</span>
    <span class="synStatement">else</span> putStrLn <span class="synConstant">&quot;7 is not in someSet&quot;</span>
</pre><p>実行結果:</p>
<pre class="code" data-lang="" data-unlink>$ runghc ModC.hs
7 is not in someSet</pre><p>Orphan instanceの危険性が分かってきました。</p>


{% endraw %}
