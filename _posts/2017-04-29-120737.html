---
layout: post
title: PFDSを読む&#58; 二分木の改良
tags:
- OCaml
- Algorithm

---
{% raw %}
<p>長年積んでたPFDSを読み始めることにしました。<br />
積んでる間に邦訳が出たらしいのですが、とりあえず気にしない方針で。</p><p>まずは単純な二分木</p>
<pre class="code lang-ocaml" data-lang="ocaml" data-unlink><span class="synStatement">module type </span><span class="synPreProc">SET</span> <span class="synStatement">=</span>
  <span class="synPreProc">sig</span>
    <span class="synStatement">type</span> elt
    <span class="synStatement">type</span> set

    <span class="synStatement">val</span> empty : <span class="synType">unit</span> <span class="synStatement">-&gt;</span> set
    <span class="synStatement">val</span> insert : elt <span class="synStatement">-&gt;</span> set <span class="synStatement">-&gt;</span> set
    <span class="synStatement">val</span> member : elt <span class="synStatement">-&gt;</span> set <span class="synStatement">-&gt;</span> <span class="synType">bool</span>
  <span class="synPreProc">end</span>
</pre><pre class="code lang-ocaml" data-lang="ocaml" data-unlink><span class="synStatement">module type </span><span class="synPreProc">ORDERED</span> <span class="synStatement">=</span>
  <span class="synPreProc">sig</span>
    <span class="synStatement">type</span> t

    <span class="synStatement">val</span> eq : t <span class="synStatement">-&gt;</span> t <span class="synStatement">-&gt;</span> <span class="synType">bool</span>
    <span class="synStatement">val</span> lt : t <span class="synStatement">-&gt;</span> t <span class="synStatement">-&gt;</span> <span class="synType">bool</span>
    <span class="synStatement">val</span> leq : t <span class="synStatement">-&gt;</span> t <span class="synStatement">-&gt;</span> <span class="synType">bool</span>
  <span class="synPreProc">end</span>

<span class="synStatement">module</span><span class="synPreProc"> UnbalancedSet</span> (<span class="synPreProc">Elt</span> : <span class="synPreProc">ORDERED</span>)
       : <span class="synPreProc">SET</span> <span class="synStatement">with</span> <span class="synStatement">type</span> elt <span class="synStatement">=</span> <span class="synPreProc">Elt</span>.t <span class="synStatement">=</span>
  <span class="synPreProc">struct</span>
    <span class="synStatement">type</span> elt <span class="synStatement">=</span> <span class="synPreProc">Elt</span>.t
    <span class="synStatement">type</span> tree <span class="synStatement">=</span>
      <span class="synStatement">|</span> <span class="synConstant">E</span>
      <span class="synStatement">|</span> <span class="synConstant">T</span> <span class="synStatement">of</span> tree <span class="synStatement">*</span> elt <span class="synStatement">*</span> tree
    <span class="synStatement">type</span> set <span class="synStatement">=</span> tree

    <span class="synStatement">let</span> empty <span class="synConstant">()</span> <span class="synStatement">=</span> <span class="synConstant">E</span>

    <span class="synStatement">let</span> <span class="synStatement">rec</span> member x tree <span class="synStatement">=</span> <span class="synStatement">match</span> tree <span class="synStatement">with</span>
      <span class="synStatement">|</span> <span class="synConstant">E</span> <span class="synStatement">-&gt;</span> <span class="synConstant">false</span>
      <span class="synStatement">|</span> <span class="synConstant">T</span> <span class="synStatement">(</span>a, y, b<span class="synStatement">)</span> <span class="synStatement">-&gt;</span>
         <span class="synStatement">if</span> <span class="synPreProc">Elt</span>.lt x y <span class="synStatement">then</span> member x a
         <span class="synStatement">else</span> <span class="synStatement">if</span> <span class="synPreProc">Elt</span>.lt y x <span class="synStatement">then</span> member x b
         <span class="synStatement">else</span> <span class="synConstant">true</span>

    <span class="synStatement">let</span> <span class="synStatement">rec</span> insert x tree <span class="synStatement">=</span> <span class="synStatement">match</span> tree <span class="synStatement">with</span>
      <span class="synStatement">|</span> <span class="synConstant">E</span> <span class="synStatement">-&gt;</span> <span class="synConstant">T</span> <span class="synStatement">(</span><span class="synConstant">E</span>, x, <span class="synConstant">E</span><span class="synStatement">)</span>
      <span class="synStatement">|</span> <span class="synConstant">T</span> <span class="synStatement">(</span>a, y, b<span class="synStatement">)</span> <span class="synStatement">-&gt;</span>
         <span class="synStatement">if</span> <span class="synPreProc">Elt</span>.lt x y <span class="synStatement">then</span> <span class="synConstant">T</span> <span class="synStatement">(</span>insert x a, y, b<span class="synStatement">)</span>
         <span class="synStatement">else</span> <span class="synStatement">if</span> <span class="synPreProc">Elt</span>.lt y x <span class="synStatement">then</span> <span class="synConstant">T</span> <span class="synStatement">(</span>a, y, insert x b<span class="synStatement">)</span>
         <span class="synStatement">else</span> tree
  <span class="synPreProc">end</span>
</pre><p>最も簡単な二分木の実装です。<br />
これを少しずつ改良していきます。</p><p>まずは、無駄な比較を減らしましょう。上のコードでは木の深さをdとすると、最大で2d回の比較をおこなうことになってしまいます。<br />
x < y とならないような(= xと等しいかもしれない)yをおぼえていくことによって、この比較の回数をd + 1回に減らすことができます。</p>
<pre class="code lang-ocaml" data-lang="ocaml" data-unlink><span class="synStatement">module</span><span class="synPreProc"> UnbalancedSet_Ex2_2</span> (<span class="synPreProc">Elt</span> : <span class="synPreProc">ORDERED</span>)
       : <span class="synPreProc">SET</span> <span class="synStatement">with</span> <span class="synStatement">type</span> elt <span class="synStatement">=</span> <span class="synPreProc">Elt</span>.t <span class="synStatement">=</span>
  <span class="synPreProc">struct</span>
    ...
    <span class="synStatement">let</span> insert x tree <span class="synStatement">=</span>
      <span class="synStatement">let</span> <span class="synStatement">rec</span> insert' parent x tree <span class="synStatement">=</span> <span class="synStatement">match</span> tree <span class="synStatement">with</span>
        <span class="synStatement">|</span> <span class="synConstant">E</span> <span class="synStatement">-&gt;</span>
           <span class="synStatement">begin</span> <span class="synStatement">match</span> parent <span class="synStatement">with</span>
                 <span class="synStatement">|</span> <span class="synConstant">Some</span> x' <span class="synStatement">when</span> <span class="synPreProc">Elt</span>.eq x x' <span class="synStatement">-&gt;</span> <span class="synConstant">E</span>
                 <span class="synStatement">|</span> <span class="synStatement">_</span> <span class="synStatement">-&gt;</span> <span class="synConstant">T</span> <span class="synStatement">(</span><span class="synConstant">E</span>, x, <span class="synConstant">E</span><span class="synStatement">)</span>
           <span class="synStatement">end</span>
        <span class="synStatement">|</span> <span class="synConstant">T</span> <span class="synStatement">(</span>a, y, b<span class="synStatement">)</span> <span class="synStatement">-&gt;</span>
           <span class="synStatement">if</span> <span class="synPreProc">Elt</span>.lt x y <span class="synStatement">then</span> <span class="synConstant">T</span> <span class="synStatement">(</span>insert' parent x a, y, b<span class="synStatement">)</span>
           <span class="synStatement">else</span> <span class="synConstant">T</span> <span class="synStatement">(</span>a, y, insert' <span class="synStatement">(</span><span class="synConstant">Some</span> y<span class="synStatement">)</span> x b<span class="synStatement">)</span>
      <span class="synStatement">in</span> insert' <span class="synConstant">None</span> x tree
  <span class="synPreProc">end</span>
</pre><p>これで少しだけ高速化できました。</p><p>次に、無駄な要素のコピーを減らしましょう。<br />
現在のところ、以下のようなツリーxsに対して要素4を追加したツリーysを新たに作った場合、xsとysは次のように要素を共有します。</p><p><span itemscope itemtype="http://schema.org/Photograph"><img src="/img/post/2017-04-29-https-cdn-ak.f.st-hatena.com-images-fotolife-c-cloudear8-20170429-20170429120145.png" alt="f:id:cloudear8:20170429120145p:plain" title="f:id:cloudear8:20170429120145p:plain" class="hatena-fotolife" itemprop="image"></span></p><p>しかし、例えばここで追加する要素が0であった場合、xsとysは同じツリーであるにも関わらず、以下のような要素のコピーが行われてしまいます。</p><p><span itemscope itemtype="http://schema.org/Photograph"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/c/cloudear8/20170429/20170429120151.png" alt="f:id:cloudear8:20170429120151p:plain" title="f:id:cloudear8:20170429120151p:plain" class="hatena-fotolife" itemprop="image"></span></p><p>これを解消するため、追加しようとしている要素を既に持っていた場合、引数のツリーをそのまま返すようにします。</p>
<pre class="code lang-ocaml" data-lang="ocaml" data-unlink><span class="synStatement">module</span><span class="synPreProc"> UnbalancedSet_Ex2_4</span> (<span class="synPreProc">Elt</span> : <span class="synPreProc">ORDERED</span>) : <span class="synPreProc">SET</span> <span class="synStatement">=</span>
  <span class="synPreProc">struct</span>
    ...
    <span class="synStatement">exception</span> <span class="synConstant">Element_Exists</span>
    <span class="synStatement">let</span> insert x tree <span class="synStatement">=</span>
      <span class="synStatement">let</span> <span class="synStatement">rec</span> insert' parent x tree <span class="synStatement">=</span> <span class="synStatement">match</span> tree <span class="synStatement">with</span>
        <span class="synStatement">|</span> <span class="synConstant">E</span> <span class="synStatement">-&gt;</span>
           <span class="synStatement">begin</span> <span class="synStatement">match</span> parent <span class="synStatement">with</span>
                 <span class="synStatement">|</span> <span class="synConstant">Some</span> x' <span class="synStatement">when</span> <span class="synPreProc">Elt</span>.eq x x' <span class="synStatement">-&gt;</span> <span class="synStatement">raise</span> <span class="synConstant">Element_Exists</span>
                 <span class="synStatement">|</span> <span class="synStatement">_</span> <span class="synStatement">-&gt;</span> <span class="synConstant">T</span> <span class="synStatement">(</span><span class="synConstant">E</span>, x, <span class="synConstant">E</span><span class="synStatement">)</span>
           <span class="synStatement">end</span>
        <span class="synStatement">|</span> <span class="synConstant">T</span> <span class="synStatement">(</span>a, y, b<span class="synStatement">)</span> <span class="synStatement">-&gt;</span>
           <span class="synStatement">if</span> <span class="synPreProc">Elt</span>.lt x y <span class="synStatement">then</span> <span class="synConstant">T</span> <span class="synStatement">(</span>insert' parent x a, y, b<span class="synStatement">)</span>
           <span class="synStatement">else</span> <span class="synConstant">T</span> <span class="synStatement">(</span>a, y, insert' <span class="synStatement">(</span><span class="synConstant">Some</span> y<span class="synStatement">)</span> x b<span class="synStatement">)</span>
      <span class="synStatement">in</span> <span class="synStatement">try</span> insert' <span class="synConstant">None</span> x tree
         <span class="synStatement">with</span> <span class="synConstant">Element_Exists</span> <span class="synStatement">-&gt;</span> tree
  <span class="synPreProc">end</span>
</pre><p><div class="hatena-asin-detail"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/0521663504/cloudear-22/"><img src="https://images-fe.ssl-images-amazon.com/images/I/41XlPaC%2BZqL._SL160_.jpg" class="hatena-asin-detail-image" alt="Purely Functional Data Structures" title="Purely Functional Data Structures"></a><div class="hatena-asin-detail-info"><p class="hatena-asin-detail-title"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/0521663504/cloudear-22/">Purely Functional Data Structures</a></p><ul><li><span class="hatena-asin-detail-label">作者:</span> Chris Okasaki</li><li><span class="hatena-asin-detail-label">出版社/メーカー:</span> Cambridge University Press</li><li><span class="hatena-asin-detail-label">発売日:</span> 1999/07/01</li><li><span class="hatena-asin-detail-label">メディア:</span> ペーパーバック</li><li><span class="hatena-asin-detail-label">購入</span>: 5人 <span class="hatena-asin-detail-label">クリック</span>: 46回</li><li><a href="http://d.hatena.ne.jp/asin/0521663504/cloudear-22" target="_blank">この商品を含むブログ (25件) を見る</a></li></ul></div><div class="hatena-asin-detail-foot"></div></div></p><p><div class="hatena-asin-detail"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4048930567/cloudear-22/"><img src="https://images-fe.ssl-images-amazon.com/images/I/51PxIsCTlHL._SL160_.jpg" class="hatena-asin-detail-image" alt="純粋関数型データ構造" title="純粋関数型データ構造"></a><div class="hatena-asin-detail-info"><p class="hatena-asin-detail-title"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4048930567/cloudear-22/">純粋関数型データ構造</a></p><ul><li><span class="hatena-asin-detail-label">作者:</span> Chris Okasaki,稲葉一浩,遠藤侑介</li><li><span class="hatena-asin-detail-label">出版社/メーカー:</span> <a class="keyword" href="http://d.hatena.ne.jp/keyword/KADOKAWA">KADOKAWA</a></li><li><span class="hatena-asin-detail-label">発売日:</span> 2017/04/28</li><li><span class="hatena-asin-detail-label">メディア:</span> 単行本</li><li><a href="http://d.hatena.ne.jp/asin/4048930567/cloudear-22" target="_blank">この商品を含むブログを見る</a></li></ul></div><div class="hatena-asin-detail-foot"></div></div></p>


{% endraw %}
