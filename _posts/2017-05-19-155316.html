---
layout: post
title: PFDSを読む&#58; Binomial Heap
tags:
- Algorithm
- OCaml

---
{% raw %}
<p>Binomial Heapとは、Binomial Treeというデータ構造を使って作られるヒープです。</p><p>ここで、Binomial Treeとは、以下のようなデータ構造です。</p>

<ul>
<li>rankが0であるBinomial Treeは、ただ1つのノードからなるシングルトン</li>
<li>r > 0 について、rankがrであるBinomial Treeはr個の子を持ち、それらのrankはそれぞれ0, 1, ..., r - 1</li>
</ul><p>この時、rankがrのBinomial Treeは、ちょうど<img src="http://chart.apis.google.com/chart?cht=tx&chl=2%5Er" alt="2^r"/>個の子を持つことになります。</p><p><b>証明:</b><br />
rankがrのBinomial Treeの要<a class="keyword" href="http://d.hatena.ne.jp/keyword/%C1%C7%BF%F4">素数</a>を<img src="http://chart.apis.google.com/chart?cht=tx&chl=a_r" alt="a_r"/>とすると、<br />
<img src="http://chart.apis.google.com/chart?cht=tx&chl=a_0%20%3D%201" alt="a_0 = 1"/><br />
<img src="http://chart.apis.google.com/chart?cht=tx&chl=a_r%20%3D%201%20%2B%20%5CSigma_%7Bk%20%3D%200%7D%5E%7Br%20-%201%7Da_k" alt="a_r = 1 + \Sigma_{k = 0}^{r - 1}a_k"/><br />
したがって、<br />
<img src="http://chart.apis.google.com/chart?cht=tx&chl=a_%7Br%2B1%7D%20-%20a_r%20%3D%20%281%20%2B%20%5CSigma_%7Bk%20%3D%200%7D%5E%7Br%7Da_k%29%20-%20%281%20%2B%20%5CSigma_%7Bk%20%3D%200%7D%5E%7Br%20-%201%7Da_k%29" alt="a_{r+1} - a_r = (1 + \Sigma_{k = 0}^{r}a_k) - (1 + \Sigma_{k = 0}^{r - 1}a_k)"/><br />
<img src="http://chart.apis.google.com/chart?cht=tx&chl=%3D%20a_r" alt="= a_r"/><br />
<img src="http://chart.apis.google.com/chart?cht=tx&chl=%5Ctherefore%20a_%7Br%2B1%7D%20%3D%202a_r" alt="\therefore a_{r+1} = 2a_r"/><br />
よって、<img src="http://chart.apis.google.com/chart?cht=tx&chl=a_%7Br%7D%20%3D%202%5E%7Br%7Da_0%20%3D%202%5Er" alt="a_{r} = 2^{r}a_0 = 2^r"/> ■</p><p>この性質は、実際にツリーを見てみるとわかりやすいと思います。</p><p><span itemscope itemtype="http://schema.org/Photograph"><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/c/cloudear8/20170507/20170507113403.png" alt="f:id:cloudear8:20170507113403p:plain" title="f:id:cloudear8:20170507113403p:plain" class="hatena-fotolife" itemprop="image"></span></p><p>Binomial Heapは、同じrankを持たないBinomial Treeのリストとして定義されます。rank rのBinomial Treeの要<a class="keyword" href="http://d.hatena.ne.jp/keyword/%C1%C7%BF%F4">素数</a>は<img src="http://chart.apis.google.com/chart?cht=tx&chl=2%5Er" alt="2^r"/>個ですから、二進数と同じ原理で、任意個の要素を持つBinomial Heapを作ることができます。<br />
実際、nを2進数で表した時に<img src="http://chart.apis.google.com/chart?cht=tx&chl=%5CSigma_%7Bk%3D0%7D%5E%7Bm%7Dd_k2%5Ek%20%28d_k%20%5Cin%20%5C%7B0%2C%201%5C%7D%29" alt="\Sigma_{k=0}^{m}d_k2^k (d_k \in \{0, 1\})"/>と表せた場合、<img src="http://chart.apis.google.com/chart?cht=tx&chl=d_k%20%3D%201" alt="d_k = 1"/>となるようなkをrankに持つBinomial Treeがそれぞれ1つずつあれば、それらのツリーの要<a class="keyword" href="http://d.hatena.ne.jp/keyword/%C1%C7%BF%F4">素数</a>の合計はnに等しくなるはずです。</p><p>ちなみに、Binomial Heapの操作自体も二進数のアナロジーのようになっています。</p><p>また、この時Binomial Heapが持つBinomial Treeの個数は<img src="http://chart.apis.google.com/chart?cht=tx&chl=log_2%28n%20%2B%201%29" alt="log_2(n + 1)"/>個程度となります。</p><p>さらに、Binomimal Heapは、リスト内の各Binomial Treeについて、一般的なヒープが持つ性質、すなわち、その根の部分がツリーの中での最小値であるという制約も持ちます。<br />
この制約によって、最小値の検索はヒープの各要素の根を見るだけで済むようになるので、<img src="http://chart.apis.google.com/chart?cht=tx&chl=O%28logn%29" alt="O(logn)"/>の計算量で済むことになります。</p><br />
<p>それでは、Binomial Heapを実装していきましょう。<br />
最初に完成形のコードを載せておいて、後から個別に解説していきます。</p>
<pre class="code lang-ocaml" data-lang="ocaml" data-unlink><span class="synStatement">module type </span><span class="synPreProc">ORDERED</span> <span class="synStatement">=</span>
  <span class="synPreProc">sig</span>
    <span class="synStatement">type</span> t

    <span class="synStatement">val</span> eq : t <span class="synStatement">-&gt;</span> t <span class="synStatement">-&gt;</span> <span class="synType">bool</span>
    <span class="synStatement">val</span> lt : t <span class="synStatement">-&gt;</span> t <span class="synStatement">-&gt;</span> <span class="synType">bool</span>
    <span class="synStatement">val</span> leq : t <span class="synStatement">-&gt;</span> t <span class="synStatement">-&gt;</span> <span class="synType">bool</span>
  <span class="synPreProc">end</span>

<span class="synStatement">module type </span><span class="synPreProc">HEAP</span> <span class="synStatement">=</span>
  <span class="synPreProc">sig</span>
    <span class="synStatement">type</span> t
    <span class="synStatement">type</span> elt

    <span class="synStatement">val</span> empty : <span class="synType">unit</span> <span class="synStatement">-&gt;</span> t
    <span class="synStatement">val</span> is_empty : t <span class="synStatement">-&gt;</span> <span class="synType">bool</span>

    <span class="synStatement">val</span> insert : elt <span class="synStatement">-&gt;</span> t <span class="synStatement">-&gt;</span> t
    <span class="synStatement">val</span> merge : t <span class="synStatement">-&gt;</span> t <span class="synStatement">-&gt;</span> t

    <span class="synStatement">val</span> find_min : t <span class="synStatement">-&gt;</span> elt <span class="synComment">(* raises Empty if heap is empty *)</span>
    <span class="synStatement">val</span> delete_min : t <span class="synStatement">-&gt;</span> t <span class="synComment">(* raises Empty if heap is empty *)</span>
  <span class="synPreProc">end</span>

<span class="synStatement">module</span><span class="synPreProc"> BinomialHeap</span> (<span class="synPreProc">Elt</span> : <span class="synPreProc">ORDERED</span>) : <span class="synPreProc">HEAP</span> <span class="synStatement">with</span> <span class="synStatement">type</span> elt <span class="synStatement">=</span> <span class="synPreProc">Elt</span>.t <span class="synStatement">=</span>
  <span class="synPreProc">struct</span>
    <span class="synStatement">type</span> elt <span class="synStatement">=</span> <span class="synPreProc">Elt</span>.t
    <span class="synStatement">type</span> tree <span class="synStatement">=</span> <span class="synConstant">Node</span> <span class="synStatement">of</span> <span class="synType">int</span> <span class="synStatement">*</span> elt <span class="synStatement">*</span> tree <span class="synType">list</span>
    <span class="synStatement">type</span> t <span class="synStatement">=</span> tree <span class="synType">list</span>

    <span class="synStatement">let</span> link <span class="synStatement">(</span><span class="synConstant">Node</span> <span class="synStatement">(</span>r, x1, c1<span class="synStatement">)</span> <span class="synStatement">as</span> t1<span class="synStatement">)</span> <span class="synStatement">(</span><span class="synConstant">Node</span> <span class="synStatement">(_</span>, x2, c2<span class="synStatement">)</span> <span class="synStatement">as</span> t2<span class="synStatement">)</span> <span class="synStatement">=</span>
      <span class="synStatement">if</span> <span class="synPreProc">Elt</span>.leq x1 x2 <span class="synStatement">then</span> <span class="synConstant">Node</span> <span class="synStatement">(</span>r + <span class="synConstant">1</span>, x1, t2 <span class="synStatement">::</span> c1<span class="synStatement">)</span>
      <span class="synStatement">else</span> <span class="synConstant">Node</span> <span class="synStatement">(</span>r + <span class="synConstant">1</span>, x2, t1 <span class="synStatement">::</span> c2<span class="synStatement">)</span>

    <span class="synStatement">let</span> rank <span class="synStatement">(</span><span class="synConstant">Node</span> <span class="synStatement">(</span>r, <span class="synStatement">_</span>, <span class="synStatement">_))</span> <span class="synStatement">=</span> r

    <span class="synStatement">let</span> root <span class="synStatement">(</span><span class="synConstant">Node</span> <span class="synStatement">(_</span>, x, <span class="synStatement">_))</span> <span class="synStatement">=</span> x

    <span class="synStatement">let</span> empty <span class="synConstant">()</span> <span class="synStatement">=</span> <span class="synConstant">[]</span>

    <span class="synStatement">let</span> is_empty <span class="synStatement">=</span> <span class="synStatement">function</span>
      <span class="synStatement">|</span> <span class="synConstant">[]</span> <span class="synStatement">-&gt;</span> <span class="synConstant">true</span>
      <span class="synStatement">|</span> <span class="synStatement">_</span> <span class="synStatement">-&gt;</span> <span class="synConstant">false</span>

    <span class="synStatement">let</span> <span class="synStatement">rec</span> insert_tree t heap <span class="synStatement">=</span> <span class="synStatement">match</span> heap <span class="synStatement">with</span>
      <span class="synStatement">|</span> <span class="synConstant">[]</span> <span class="synStatement">-&gt;</span> <span class="synStatement">[</span>t<span class="synStatement">]</span>
      <span class="synStatement">|</span> t' <span class="synStatement">::</span> ts' <span class="synStatement">-&gt;</span>
         <span class="synStatement">if</span> rank t <span class="synStatement">&lt;</span> rank t' <span class="synStatement">then</span> t <span class="synStatement">::</span> heap
         <span class="synStatement">else</span> insert_tree <span class="synStatement">(</span>link t t'<span class="synStatement">)</span> ts'

    <span class="synStatement">let</span> insert x h <span class="synStatement">=</span> insert_tree <span class="synStatement">(</span><span class="synConstant">Node</span> <span class="synStatement">(</span><span class="synConstant">0</span>, x, <span class="synConstant">[]</span><span class="synStatement">))</span> h

    <span class="synStatement">let</span> <span class="synStatement">rec</span> merge ts1 ts2 <span class="synStatement">=</span> <span class="synStatement">match</span> ts1, ts2 <span class="synStatement">with</span>
      <span class="synStatement">|</span> <span class="synStatement">_</span>, <span class="synConstant">[]</span> <span class="synStatement">-&gt;</span> ts1
      <span class="synStatement">|</span> <span class="synConstant">[]</span>, <span class="synStatement">_</span> <span class="synStatement">-&gt;</span> ts2
      <span class="synStatement">|</span> t1 <span class="synStatement">::</span> ts1', t2 <span class="synStatement">::</span> ts2' <span class="synStatement">-&gt;</span>
         <span class="synStatement">if</span> rank t1 <span class="synStatement">&lt;</span> rank t2 <span class="synStatement">then</span> t1 <span class="synStatement">::</span> merge ts1' ts2
         <span class="synStatement">else</span> <span class="synStatement">if</span> rank t2 <span class="synStatement">&lt;</span> rank t1 <span class="synStatement">then</span> t2 <span class="synStatement">::</span> merge ts1 ts2'
         <span class="synStatement">else</span> insert_tree <span class="synStatement">(</span>link t1 t2<span class="synStatement">)</span> <span class="synStatement">(</span>merge ts1' ts2'<span class="synStatement">)</span>

    <span class="synStatement">let</span> <span class="synStatement">rec</span> remove_min_tree : t <span class="synStatement">-&gt;</span> tree <span class="synStatement">*</span> t <span class="synStatement">=</span> <span class="synStatement">function</span>
      <span class="synStatement">|</span> <span class="synConstant">[]</span> <span class="synStatement">-&gt;</span> <span class="synStatement">raise</span> <span class="synStatement">(</span><span class="synConstant">Failure</span> <span class="synConstant">&quot;remove_min_trees&quot;</span><span class="synStatement">)</span>
      <span class="synStatement">|</span> t <span class="synStatement">::</span> <span class="synConstant">[]</span> <span class="synStatement">-&gt;</span> <span class="synStatement">(</span>t, <span class="synConstant">[]</span><span class="synStatement">)</span>
      <span class="synStatement">|</span> t <span class="synStatement">::</span> ts <span class="synStatement">-&gt;</span>
         <span class="synStatement">let</span> <span class="synStatement">(</span>t', ts'<span class="synStatement">)</span> <span class="synStatement">=</span> remove_min_tree ts
         <span class="synStatement">in</span> <span class="synStatement">if</span> <span class="synPreProc">Elt</span>.leq <span class="synStatement">(</span>root t<span class="synStatement">)</span> <span class="synStatement">(</span>root t'<span class="synStatement">)</span> <span class="synStatement">then</span> <span class="synStatement">(</span>t, ts<span class="synStatement">)</span>
            <span class="synStatement">else</span> <span class="synStatement">(</span>t', t <span class="synStatement">::</span> ts'<span class="synStatement">)</span>

    <span class="synStatement">let</span> find_min ts <span class="synStatement">=</span>
      <span class="synStatement">let</span> <span class="synStatement">(</span>t, <span class="synStatement">_)</span> <span class="synStatement">=</span> remove_min_tree ts
      <span class="synStatement">in</span> root t

    <span class="synStatement">let</span> delete_min ts <span class="synStatement">=</span>
      <span class="synStatement">let</span> <span class="synStatement">(</span><span class="synConstant">Node</span> <span class="synStatement">(_</span>, <span class="synStatement">_</span>, ts1<span class="synStatement">)</span>, ts2<span class="synStatement">)</span> <span class="synStatement">=</span> remove_min_tree ts
      <span class="synStatement">in</span> merge <span class="synStatement">(</span><span class="synPreProc">List</span>.rev ts1<span class="synStatement">)</span> ts2
  <span class="synPreProc">end</span>
</pre><p>まずはBinomialHeap.tree型です。</p>
<pre class="code lang-ocaml" data-lang="ocaml" data-unlink>    <span class="synStatement">type</span> tree <span class="synStatement">=</span> <span class="synConstant">Node</span> <span class="synStatement">of</span> <span class="synType">int</span> <span class="synStatement">*</span> elt <span class="synStatement">*</span> tree <span class="synType">list</span>
</pre><p>例によってrankをメモしてあります。<br />
これを利用してヒープ本体であるBinomialTree.t型を定義します。</p>
<pre class="code lang-ocaml" data-lang="ocaml" data-unlink>    <span class="synStatement">type</span> t <span class="synStatement">=</span> tree <span class="synType">list</span>
</pre><p>注意しなければならないのは、Binomial Heapは要素のツリーのrankが昇順になっているのに対して、Binomial Treeの子のrankは降順になっているということです。<br />
これは両者の操作方法がそれぞれ違うためです。<br />
Binomial Heapは2進数のアナロジーのような操作を行うため、rankが昇順に、Binomial Treeは子の左端に自分と同じrankのものをくっつけるという動作が頻発するため、降順になっています。</p><p>次はこれらに対する操作を定義していきます。まずはlink関数。</p>
<pre class="code lang-ocaml" data-lang="ocaml" data-unlink>    <span class="synStatement">let</span> link <span class="synStatement">(</span><span class="synConstant">Node</span> <span class="synStatement">(</span>r, x1, c1<span class="synStatement">)</span> <span class="synStatement">as</span> t1<span class="synStatement">)</span> <span class="synStatement">(</span><span class="synConstant">Node</span> <span class="synStatement">(_</span>, x2, c2<span class="synStatement">)</span> <span class="synStatement">as</span> t2<span class="synStatement">)</span> <span class="synStatement">=</span>
      <span class="synStatement">if</span> <span class="synPreProc">Elt</span>.leq x1 x2 <span class="synStatement">then</span> <span class="synConstant">Node</span> <span class="synStatement">(</span>r + <span class="synConstant">1</span>, x1, t2 <span class="synStatement">::</span> c1<span class="synStatement">)</span>
      <span class="synStatement">else</span> <span class="synConstant">Node</span> <span class="synStatement">(</span>r + <span class="synConstant">1</span>, x2, t1 <span class="synStatement">::</span> c2<span class="synStatement">)</span>
</pre><p>これは2進数でいう半加算器のようなものです。rank rのBinomial Treeを2個合成し、rank (r + 1)のBinomial Treeを生成します。</p><p>次にinsert_treeを見てみましょう。</p>
<pre class="code lang-ocaml" data-lang="ocaml" data-unlink>    <span class="synStatement">let</span> <span class="synStatement">rec</span> insert_tree t heap <span class="synStatement">=</span> <span class="synStatement">match</span> heap <span class="synStatement">with</span>
      <span class="synStatement">|</span> <span class="synConstant">[]</span> <span class="synStatement">-&gt;</span> <span class="synStatement">[</span>t<span class="synStatement">]</span>
      <span class="synStatement">|</span> t' <span class="synStatement">::</span> ts' <span class="synStatement">-&gt;</span>
         <span class="synStatement">if</span> rank t <span class="synStatement">&lt;</span> rank t' <span class="synStatement">then</span> t <span class="synStatement">::</span> heap
         <span class="synStatement">else</span> insert_tree <span class="synStatement">(</span>link t t'<span class="synStatement">)</span> ts'
</pre><p>これは2進のインクリメンタのようなものです。heapの"最下位ビット"にツリーを1つ加え、"繰り上がり"が生じれば"上の桁"にも同じ処理をしていきます。</p><p>これを各ビットに適用させることによって、2つのヒープをマージすることができます。</p>
<pre class="code lang-ocaml" data-lang="ocaml" data-unlink>    <span class="synStatement">let</span> <span class="synStatement">rec</span> merge ts1 ts2 <span class="synStatement">=</span> <span class="synStatement">match</span> ts1, ts2 <span class="synStatement">with</span>
      <span class="synStatement">|</span> <span class="synStatement">_</span>, <span class="synConstant">[]</span> <span class="synStatement">-&gt;</span> ts1
      <span class="synStatement">|</span> <span class="synConstant">[]</span>, <span class="synStatement">_</span> <span class="synStatement">-&gt;</span> ts2
      <span class="synStatement">|</span> t1 <span class="synStatement">::</span> ts1', t2 <span class="synStatement">::</span> ts2' <span class="synStatement">-&gt;</span>
         <span class="synStatement">if</span> rank t1 <span class="synStatement">&lt;</span> rank t2 <span class="synStatement">then</span> t1 <span class="synStatement">::</span> merge ts1' ts2
         <span class="synStatement">else</span> <span class="synStatement">if</span> rank t2 <span class="synStatement">&lt;</span> rank t1 <span class="synStatement">then</span> t2 <span class="synStatement">::</span> merge ts1 ts2'
         <span class="synStatement">else</span> insert_tree <span class="synStatement">(</span>link t1 t2<span class="synStatement">)</span> <span class="synStatement">(</span>merge ts1' ts2'<span class="synStatement">)</span>
</pre><p>次にfind_min, delete_minですが、これらを実装するために補助関数delete_min_treeを定義します。</p>
<pre class="code lang-ocaml" data-lang="ocaml" data-unlink>    <span class="synStatement">let</span> <span class="synStatement">rec</span> remove_min_tree : t <span class="synStatement">-&gt;</span> tree <span class="synStatement">*</span> t <span class="synStatement">=</span> <span class="synStatement">function</span>
      <span class="synStatement">|</span> <span class="synConstant">[]</span> <span class="synStatement">-&gt;</span> <span class="synStatement">raise</span> <span class="synStatement">(</span><span class="synConstant">Failure</span> <span class="synConstant">&quot;remove_min_trees&quot;</span><span class="synStatement">)</span>
      <span class="synStatement">|</span> t <span class="synStatement">::</span> <span class="synConstant">[]</span> <span class="synStatement">-&gt;</span> <span class="synStatement">(</span>t, <span class="synConstant">[]</span><span class="synStatement">)</span>
      <span class="synStatement">|</span> t <span class="synStatement">::</span> ts <span class="synStatement">-&gt;</span>
         <span class="synStatement">let</span> <span class="synStatement">(</span>t', ts'<span class="synStatement">)</span> <span class="synStatement">=</span> remove_min_tree ts
         <span class="synStatement">in</span> <span class="synStatement">if</span> <span class="synPreProc">Elt</span>.leq <span class="synStatement">(</span>root t<span class="synStatement">)</span> <span class="synStatement">(</span>root t'<span class="synStatement">)</span> <span class="synStatement">then</span> <span class="synStatement">(</span>t, ts<span class="synStatement">)</span>
            <span class="synStatement">else</span> <span class="synStatement">(</span>t', t <span class="synStatement">::</span> ts'<span class="synStatement">)</span>
</pre><p>各Binomial Treeは根が最小値になっているので、remove_min_treeの返り値の左の値の根が最小値となります。<br />
これを利用してfind_min, delete_minを定義します。</p>
<pre class="code lang-ocaml" data-lang="ocaml" data-unlink>    <span class="synStatement">let</span> find_min ts <span class="synStatement">=</span>
      <span class="synStatement">let</span> <span class="synStatement">(</span>t, <span class="synStatement">_)</span> <span class="synStatement">=</span> remove_min_tree ts
      <span class="synStatement">in</span> root t

    <span class="synStatement">let</span> delete_min ts <span class="synStatement">=</span>
      <span class="synStatement">let</span> <span class="synStatement">(</span><span class="synConstant">Node</span> <span class="synStatement">(_</span>, <span class="synStatement">_</span>, ts1<span class="synStatement">)</span>, ts2<span class="synStatement">)</span> <span class="synStatement">=</span> remove_min_tree ts
      <span class="synStatement">in</span> merge <span class="synStatement">(</span><span class="synPreProc">List</span>.rev ts1<span class="synStatement">)</span> ts2
</pre><p>delete_minの中でts1をrevしているのは、Binomial Treeの子のrankの並びとBinomial Heapの要素のrankの並びが逆順になっているためです。</p>


{% endraw %}
