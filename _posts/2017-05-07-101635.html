---
layout: post
title: PFDSを読む&#58; Weight-biased Leftist Heap
tags:
- Algorithm
- OCaml

---
{% raw %}
<p><iframe src="http://inkar-us-i.hatenablog.com/embed/2017/05/07/011644" title="PFDSを読む: Leftist Heapの実装 - きくらげ観察日記" class="embed-card embed-blogcard" scrolling="no" frameborder="0" style="display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;"></iframe><cite class="hatena-citation"><a href="/2017/05/07/011644.html">inkar-us-i.hatenablog.com</a></cite></p><p>こちらの記事でLeftist Heapの紹介をしましたが、今回はその亜種であるWeight-biased Leftist Heapを紹介します。<br />
このデータ構造はほとんどLeftist Heapと同様ですが、rankのかわりに要<a class="keyword" href="http://d.hatena.ne.jp/keyword/%C1%C7%BF%F4">素数</a>が左に偏るようになります。すなわち、</p>

<ol>
<li>根の部分が常に最小値となる</li>
<li>全てのノードについて、その左側の子の要<a class="keyword" href="http://d.hatena.ne.jp/keyword/%C1%C7%BF%F4">素数</a>は、右側の子の要<a class="keyword" href="http://d.hatena.ne.jp/keyword/%C1%C7%BF%F4">素数</a>以上である</li>
</ol><p>以下が実装になります。ここで、HEAP, ORDEREDは上の記事と同様のものです。</p>
<pre class="code lang-ocaml" data-lang="ocaml" data-unlink><span class="synComment">(* Weight-biased leftist heap  *)</span>
<span class="synStatement">module</span><span class="synPreProc"> WBLHeap</span> (<span class="synPreProc">Elt</span> : <span class="synPreProc">ORDERED</span>)
       : <span class="synPreProc">HEAP</span> <span class="synStatement">with</span> <span class="synStatement">type</span> elt <span class="synStatement">=</span> <span class="synPreProc">Elt</span>.t <span class="synStatement">=</span>
  <span class="synPreProc">struct</span>
    <span class="synStatement">type</span> elt <span class="synStatement">=</span> <span class="synPreProc">Elt</span>.t
    <span class="synStatement">type</span> t <span class="synStatement">=</span>
      <span class="synStatement">|</span> <span class="synConstant">E</span>
      <span class="synStatement">|</span> <span class="synConstant">T</span> <span class="synStatement">of</span> <span class="synType">int</span> <span class="synStatement">*</span> elt <span class="synStatement">*</span> t <span class="synStatement">*</span> t

    <span class="synStatement">let</span> size <span class="synStatement">=</span> <span class="synStatement">function</span>
      <span class="synStatement">|</span> <span class="synConstant">E</span> <span class="synStatement">-&gt;</span> <span class="synConstant">0</span>
      <span class="synStatement">|</span> <span class="synConstant">T</span> <span class="synStatement">(</span>s, <span class="synStatement">_</span>, <span class="synStatement">_</span>, <span class="synStatement">_)</span> <span class="synStatement">-&gt;</span> s

    <span class="synStatement">let</span> make_t x a b <span class="synStatement">=</span>
      <span class="synStatement">if</span> size a <span class="synStatement">&gt;=</span> size b <span class="synStatement">then</span> <span class="synConstant">T</span> <span class="synStatement">(</span><span class="synConstant">1</span> + size a + size b, x, a, b<span class="synStatement">)</span>
      <span class="synStatement">else</span> <span class="synConstant">T</span> <span class="synStatement">(</span><span class="synConstant">1</span> + size a + size b, x, b, a<span class="synStatement">)</span>

    <span class="synStatement">let</span> empty <span class="synConstant">()</span> <span class="synStatement">=</span> <span class="synConstant">E</span>

    <span class="synStatement">let</span> is_empty <span class="synStatement">=</span> <span class="synStatement">function</span>
      <span class="synStatement">|</span> <span class="synConstant">E</span> <span class="synStatement">-&gt;</span> <span class="synConstant">true</span>
      <span class="synStatement">|</span> <span class="synStatement">_</span> <span class="synStatement">-&gt;</span> <span class="synConstant">false</span>

    <span class="synStatement">let</span> <span class="synStatement">rec</span> merge h1 h2 <span class="synStatement">=</span> <span class="synStatement">match</span> h1, h2 <span class="synStatement">with</span>
      <span class="synStatement">|</span> <span class="synStatement">_</span>, <span class="synConstant">E</span> <span class="synStatement">-&gt;</span> h1
      <span class="synStatement">|</span> <span class="synConstant">E</span>, <span class="synStatement">_</span> <span class="synStatement">-&gt;</span> h2
      <span class="synStatement">|</span> <span class="synConstant">T</span> <span class="synStatement">(_</span>, x1, a1, b1<span class="synStatement">)</span>, <span class="synConstant">T</span> <span class="synStatement">(_</span>, x2, a2, b2<span class="synStatement">)</span> <span class="synStatement">-&gt;</span>
         <span class="synStatement">if</span> <span class="synPreProc">Elt</span>.lt x1 x2
         <span class="synStatement">then</span> make_t x1 a1 <span class="synStatement">(</span>merge b1 h2<span class="synStatement">)</span>
         <span class="synStatement">else</span> make_t x2 a2 <span class="synStatement">(</span>merge h1 b2<span class="synStatement">)</span>

    <span class="synStatement">let</span> insert x h <span class="synStatement">=</span> merge <span class="synStatement">(</span><span class="synConstant">T</span> <span class="synStatement">(</span><span class="synConstant">1</span>, x, <span class="synConstant">E</span>, <span class="synConstant">E</span><span class="synStatement">))</span> h

    <span class="synStatement">let</span> find_min <span class="synStatement">=</span> <span class="synStatement">function</span>
      <span class="synStatement">|</span> <span class="synConstant">T</span> <span class="synStatement">(_</span>, x, <span class="synStatement">_</span>, <span class="synStatement">_)</span> <span class="synStatement">-&gt;</span> x
      <span class="synStatement">|</span> <span class="synConstant">E</span> <span class="synStatement">-&gt;</span> <span class="synStatement">raise</span> <span class="synConstant">Empty</span>

    <span class="synStatement">let</span> delete_min <span class="synStatement">=</span> <span class="synStatement">function</span>
      <span class="synStatement">|</span> <span class="synConstant">T</span> <span class="synStatement">(_</span>, <span class="synStatement">_</span>, a, b<span class="synStatement">)</span> <span class="synStatement">-&gt;</span> merge a b
      <span class="synStatement">|</span> <span class="synConstant">E</span> <span class="synStatement">-&gt;</span> <span class="synStatement">raise</span> <span class="synConstant">Empty</span>

    <span class="synStatement">let</span> <span class="synStatement">rec</span> from_list xs <span class="synStatement">=</span>
      <span class="synStatement">let</span> <span class="synStatement">rec</span> iter res xs <span class="synStatement">=</span> <span class="synStatement">match</span> xs <span class="synStatement">with</span>
        <span class="synStatement">|</span> a <span class="synStatement">::</span> b <span class="synStatement">::</span> xs <span class="synStatement">-&gt;</span> iter <span class="synStatement">(</span>merge a b <span class="synStatement">::</span> res<span class="synStatement">)</span> xs
        <span class="synStatement">|</span> a <span class="synStatement">::</span> <span class="synConstant">[]</span> <span class="synStatement">-&gt;</span> a <span class="synStatement">::</span> res
        <span class="synStatement">|</span> <span class="synConstant">[]</span> <span class="synStatement">-&gt;</span> res <span class="synStatement">in</span>
      <span class="synStatement">let</span> <span class="synStatement">rec</span> from_list' xs <span class="synStatement">=</span> <span class="synStatement">match</span> iter <span class="synConstant">[]</span> xs <span class="synStatement">with</span>
        <span class="synStatement">|</span> <span class="synConstant">[]</span> <span class="synStatement">-&gt;</span> <span class="synStatement">raise</span> <span class="synConstant">Empty</span>
        <span class="synStatement">|</span> h <span class="synStatement">::</span> <span class="synConstant">[]</span> <span class="synStatement">-&gt;</span> h
        <span class="synStatement">|</span> xs' <span class="synStatement">-&gt;</span> from_list' xs'
      <span class="synStatement">in</span> from_list' <span class="synStatement">(</span><span class="synPreProc">List</span>.rev_map <span class="synStatement">(fun</span> x <span class="synStatement">-&gt;</span> <span class="synConstant">T</span> <span class="synStatement">(</span><span class="synConstant">1</span>, x, <span class="synConstant">E</span>, <span class="synConstant">E</span><span class="synStatement">))</span> xs<span class="synStatement">)</span>
  <span class="synPreProc">end</span>
</pre><p><div class="hatena-asin-detail"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/0521663504/cloudear-22/"><img src="https://images-fe.ssl-images-amazon.com/images/I/41XlPaC%2BZqL._SL160_.jpg" class="hatena-asin-detail-image" alt="Purely Functional Data Structures" title="Purely Functional Data Structures"></a><div class="hatena-asin-detail-info"><p class="hatena-asin-detail-title"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/0521663504/cloudear-22/">Purely Functional Data Structures</a></p><ul><li><span class="hatena-asin-detail-label">作者:</span> Chris Okasaki</li><li><span class="hatena-asin-detail-label">出版社/メーカー:</span> Cambridge University Press</li><li><span class="hatena-asin-detail-label">発売日:</span> 1999/07/01</li><li><span class="hatena-asin-detail-label">メディア:</span> ペーパーバック</li><li><span class="hatena-asin-detail-label">購入</span>: 5人 <span class="hatena-asin-detail-label">クリック</span>: 46回</li><li><a href="http://d.hatena.ne.jp/asin/0521663504/cloudear-22" target="_blank">この商品を含むブログ (25件) を見る</a></li></ul></div><div class="hatena-asin-detail-foot"></div></div><div class="hatena-asin-detail"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4048930567/cloudear-22/"><img src="https://images-fe.ssl-images-amazon.com/images/I/51PxIsCTlHL._SL160_.jpg" class="hatena-asin-detail-image" alt="純粋関数型データ構造" title="純粋関数型データ構造"></a><div class="hatena-asin-detail-info"><p class="hatena-asin-detail-title"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4048930567/cloudear-22/">純粋関数型データ構造</a></p><ul><li><span class="hatena-asin-detail-label">作者:</span> Chris Okasaki,稲葉一浩,遠藤侑介</li><li><span class="hatena-asin-detail-label">出版社/メーカー:</span> <a class="keyword" href="http://d.hatena.ne.jp/keyword/KADOKAWA">KADOKAWA</a></li><li><span class="hatena-asin-detail-label">発売日:</span> 2017/04/28</li><li><span class="hatena-asin-detail-label">メディア:</span> 単行本</li><li><a href="http://d.hatena.ne.jp/asin/4048930567/cloudear-22" target="_blank">この商品を含むブログを見る</a></li></ul></div><div class="hatena-asin-detail-foot"></div></div></p>


{% endraw %}
