---
layout: post
title: Coqのintrosでパターンマッチング
tags:
- Coq

---
{% raw %}
<p>destructは以下のような代数的データ型</p>
<pre class="code" data-lang="" data-unlink>Inductive T : Type :=
| C1 : x11 -&gt; x12 -&gt; ... -&gt; T
| C2 : x21 -&gt; x22 -&gt; ... -&gt; T
...
| Cn : xn1 -&gt; xn2 -&gt; ... -&gt; T.</pre><p>の値xに対して、</p>
<pre class="code" data-lang="" data-unlink>destruct x as [x11 x22 ... | x21 x22 ... | ... | xn1 xn2 ... ]</pre><p>でパターンマッチングを行うことができますが、このパターンをintros内でも使うことができます。</p>
<pre class="code" data-lang="" data-unlink>Goal forall x : bool, negb (negb x) = x.
Proof.
  intros [|]. (* xをintrosしつつ、destruct x相当のことができる *)
  - (* case x = true *)
    reflexivity.
  - (* case x = false *)
    reflexivity.
Qed.</pre><p>この例だと微妙な感じですが、andやorを分解するとき等に少し便利です。</p>
<pre class="code" data-lang="" data-unlink>Goal forall P Q : Prop, (P \/ Q) /\ ~Q -&gt; P.
Proof.
  intros P Q [[HP | HQ] NQ]. (* NQ : ~Q *)
  (* P \/ Q の部分で分岐する *)
  - (* case HP : P *)
    assumption.
  - (* case HQ : Q *)
    contradiction.
Qed.</pre>

{% endraw %}
